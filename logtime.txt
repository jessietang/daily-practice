2017/2/7:
1.关于px rem转换的问题
首先html页面首先引入<script type="text/javascript" src="../static/js/fileflex.js"></script>， 参考：https://github.com/amfe/article/issues/17 
执行这个JS后，会在<html>元素上增加一个data-dpr属性，以及一个font-size样式。JS会根据不同的设备添加不同的data-dpr值，比如说2或者3，同时会给html加上对应的font-size的值，比如说75px。
如此一来，页面中的元素，都可以通过rem单位来设置。他们会根据html元素的font-size值做相应的计算，从而实现屏幕的适配效果。
D:\workspace\activity\src\scss\mixin.scss下面的pxrem这个混合宏模块
@mixin pxrem($property, $px-values) {
    @if type-of($px-values) == "number"{
        #{$property}: $px-values / $standardNum * 1rem;
    }
    @else {
        $rem-values:();
        @each $value in $px-values{
            @if $value == 0 or type-of($value) != "number"{
                $rem-values: append($rem-values, $value);
            }
            @else{
                $rem-values: append($rem-values, $value / $standardNum * 1rem);
            }
        }
        #{$property}: $rem-values;
    }
}
在scss里面这样用：@include pxrem(padding, 240 30 15 30);
$standardNum: 75; 这个看给的设计图的宽度是多少，如果是750px,这里就写75，如果是650px，这里就写65.
scss文件里面公共的部分：
@import '../mixin';
@import '../rest';
@import '../flexmixin';
@import '../common';
$standardNum: 75;

body {
	height: 100%;
	position: relative;
	margin: 0 auto;
	width: 10rem;
	overflow-x: hidden;
	background-color: #2a00e0;
	color: #fff;
}

关于sass的补充知识：
1).混合宏：@mixin pxrem($property, $px-values) 这个就是定义一个混合宏
混合宏的调用：@include pxprem(width,200);  or  @include pxprem(padding, 240 30 15 30);
2).占位符：%fx {display: flex;}   or   %fxd-r {flex-direction: row;}
占位符的调用：@extend %fx;   or   @extend %fxd-r;



2.flex布局 多列垂直居中对齐
容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）

父容器{
	overflow: hidden;
	display: flex;
	flex-direction: row;//横向排列
	justify-content: center;//定义项目在主轴上的对齐方式---居中
	align-items: center;//交叉轴的中点对齐
}
参考代码：
.reckon {
	@include pxrem(width, 730);
	overflow: hidden;
	@include pxrem(padding, 30 0);
	@include pxrem(margin, 8 auto);
	background: linear-gradient(to right, #d02cd4, #121068);
	display: flex;
	@extend %fxd-r;
	@extend %jc-c;
	@extend %ai-c;
}

3.app页面展示
D:\workspace\activity\src\module 在这里新增页面，然后cmd里面进到D:\workspace\activity，执行gulp serve，就跑起来了，
具体查看某一个页面这样访问http://localhost:3000/src/module/artCoefficient.html。
修改或者新增完成后，执行gulp命令，将scss文件打包成这个D:\workspace\activity\src\static\css下面的css文件，
记住scss只是一个编译工具，html页面中调用的还是css文件。


2017/2/8：
1.正则表达式
首先，让我们看看两个特别的字符：'^' 和 ‘$' 他们是分别用来匹配字符串的开始和结束，以下分别举例说明
"^The": 匹配以 "The"开头的字符串;
"of despair$": 匹配以 "of despair" 结尾的字符串;
"^abc$": 匹配以abc开头和以abc结尾的字符串，实际上是只有abc与之匹配
"notice": 匹配包含notice的字符串

项目中：
function getStatus(name) {
	var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
	var r = window.location.search.substr(1).match(reg);
	if (r !== null) return unescape(r[2]);
	return null;
};
其中的var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");是用来获取页面url的某个url参数的方法。
(^|&)这个是匹配以&开头或前面没有字符的内容。([^&]*)表示不包含&的任意个字符。(&|$)表示以&结尾或者后面没有字符的内容。
这个正则是寻找& + url参数名字 = 值 + &; &可以不存在。
var r = window.location.search.substr(1).match(reg);
if (r !== null) return unescape(r[2]);
return null;
这里是开始匹配，找到了返回对应url值，没找到返回null.
举个栗子： http://www.cuit.edu.cn?channelCode=android&name=cuit&msg=test

window.location.search.substr(1).match(new RegExp("(^|&)"+ 'channelCode' +"=([^&]*)(&|$)"));  ===> 返回的是 ["channelCode=android&", "", "android", "&"]
window.location.search.substr(1).match(new RegExp("(^|&)"+ 'name' +"=([^&]*)(&|$)"));  ===> 返回的是 ["&name=cuit&", "&", "cuit", "&"]

2.zepto.js


3.box-sizing: border-box；
W3C的盒模型方式被称为“content-box”，IE盒模型的被称为“border-box”，
使用box-sizing: border-box;就是为了在设置有padding值和border值的时候不把宽度撑开。

4.JavaScript toFixed() 方法把Number四舍五入为指定小数位数的数字。


2017/2/9：
1.angular作用域的理解，参考D:\others\myWorks\angular-base\再学Angular\demo
AngularJS有了三种自定义的作用域绑定方式：

　　1 基于【字符串】的绑定：使用@操作符，双引号内的内容当做字符串进行绑定。

　　2 基于【变量】的绑定：使用=操作符，绑定的内容是个变量。

　　3 基于【方法】的绑定：使用&操作符，绑定的内容时个方法。
2.angular-myphonecat项目复习，重新看了一遍原理，但是没有自己敲代码来看。

3.git常用命令复习
查看当前分支：git branch (显示结果中带有*号的是当前分支)
查看所有分支： git branch -a
切换到test1分支： git checkout test1
创建分支test2并切换到test2分支：git checkout -b test2
删除分支test3：git checkout -d test3
合并分支test4到dev分支：先切换到dev分支（git checkout dev）,再合并分支test4（git merge test4）

4.git命令应用
1).创建一个本地分支并切换到该分支 
	git checkout -b branchForBug1
2).远程分支就是本地分支Push到服务器，比如master就是一个最典型的远程分支（默认）。下面是把分支推到远程分支。
	git push origin branchForBug1
推送本地分支到远程分支上面去语法：git push origin local_branch:remote_branch
这个操作，local_branch必须为你本地存在的分支，remote_branch为远程分支，如果remote_branch不存在则会自动创建分支。

3).一个例子示范：
	当前分支在master
	git checkout -b bug1
	修改test1.html
	git status
	git add test1.html
	git commit -m"modify test1.html"
	git push origin bug1 (把本地分支bug1推送到远程分支上面去了)
	修改完成后，合并bug1分支到master
	git checkout master  (这时test1.html又回到未修改前的版本)
	git merge bug1
	merge完成之后，把本地master分支的修改提交到远程master
	git push
	现在远程和本地的master分支上面的test1.html文件都是修改后的文件了
	
4).切换到web branch
	git checkout web
	git pull origin web
	git push origin web
	然后修改web分支里面的东西，最后直接add,commit,push就可以了。

5).修改了代码，commit了，但是没有push, 突然发现有问题了（比如pull代码的时候发生了冲突），想回退到commit之前，执行代码：git reset --hard origin/dev	
2017/2/10：
1.复习vue.js基础


2017/2/13：
1.复习正则
//正则表达式复习
    // 1).过滤出一个字符串中的数字
    var string1 = '#@1.309$';
    //把所有不是数字不是.也不是$的字符替换成空字符串
    //i : ignore  g: global
    var str1 = string1.replace(/[^\d,^{.},^{$}]/ig, '');
    var str1_1 = string1.replace(/[^\d,{.},{$}]/ig, '');
    console.log(str1); // 1.309$
    console.log(str1_1); // 1.309$
    var str1_11 = string1.replace(/[^{\d,{.},{$}}]/ig,'');  // 这个算是标准写法把！！！
    console.log(str1_11); // 1.309$
    //把所有数字和.替换成字母t
    var str1_2 = string1.replace(/[\d,{.}]/ig,'t');
    console.log(str1_2); //#@ttttt$

    //2).找到第一个出现数字的位置
    var string2 = 'fdjk@1.23efj';
    console.log(string2.search(/\d/)); // 5

    //3).三个数字连着的
    var string3 = 'tyd35h345fsa';
    var str3 = string3.match(/\d\d\d/g);
    console.log(str3); //["345"]

    //4).若干个数字
    var string4 = 'hs5624mf734f32f5dd0';
    var str4 = string4.match(/\d+/g);
    console.log(str4); // ["5624", "734", "32", "5", "0"]

    //5).除了大写字母和数字以外的
    var string5 = '#jTyhT$T78s0s';
    var str5 = string5.replace(/[^\d,^A-Z]/g,'Q');
    console.log(str5); // QQTQQTQT78Q0Q

    //6).除了小写字母和数字以外的
    var string6 = '#jTyhT$T78s0s';
    var str6 = string6.replace(/[^a-z,^\d]/g,'H');
    console.log(str6); // HjHyhHHH78s0s

    //7).^ 和 $ 分别用来匹配字符串的开头和结束
    // ^匹配开头，注意与‘非’区分开
    var testStr1 = 'mabcde123';
    var testStr2 = 'abcde123';
    var testStr3 = '12ab34cd';
    //匹配以ab字符串开头的字符串，如果匹配到了就返回字符串构成的数组，没匹配到就返回null
    console.log(testStr1.match(/(^ab)/g)); // null
    //把以字符串m开头的字符替换成M
    console.log(testStr1.replace(/(^m)/g,'M')); // Mabcde123
    //把不是字符m的所有字符替换成M
    console.log(testStr1.replace(/[^{m,c}]/g,'M')); // mMMcMMMMM
    //把不是字符m的所有字符替换成M
    console.log(testStr1.replace(/[^m,^c]/g,'M')); // mMMcMMMMM
    //把所有不是小写字母的字符替换成6
    console.log(testStr1.replace(/[^a-z]/g,'6')); // mabcde666
    //把以小写字母开头的字符替换成6
    console.log(testStr1.replace(/^[a-z]/g,'6')); // 6abcde123
    //匹配以ab字符串开头的字符串，如果匹配到了就返回字符串构成的数组，没匹配到就返回null
    console.log(testStr2.match(/(^ab)/g)); // ["ab"]
    //把所有非数字字符替换成T
    console.log(testStr3.replace(/[^\d]/g,'T')); // 12TT34TT
    //把所有非数字字符替换成T
    console.log(testStr3.replace(/[^0-9]/g,'T')); //12TT34TT
    //把以数字开始的字符替换成T
    console.log(testStr3.replace(/^[\d]/g,'T')); // T2ab34cd
    //把以数字开始的字符替换成T
    console.log(testStr3.replace(/^[0-9]/g, 'T')); //T2ab34cd
    // 从一个字符串中截取出浮点数
    console.log("kl$100.08".replace(/[^{(0-9),{.}}]/ig,"")); // 100.08
	
2.D:\workspace\truck\truck-web\outside\src\static\js\share\couponShare.js
感觉这个js好像这里有问题：
if (!app.isGet) {
			return
		}
【没有任何问题，isGet=false代表已经领过了， isGet = true代表没有领取过】


2017/2/14：
1).查看gulpfile.js文件，复习和学习gulp知识。查看：D:\others\gulpfile.js
2).写了两个博客



2017/2/15：
1.background-origin: padding-box(default) / border-box / content-box;  背景图像相对于内边距框、边框盒、内容框来定位；
2.transform: rotate3d(1,0,0,30deg); 《==》transform: rotateX(30deg);  沿着x轴旋转30度。
3.text-shadow: h-shadow v-shadow blur color;
h-shadow 水平阴影的距离
v-shadow 垂直阴影的距离
blur 可选 模糊的距离
color 阴影的颜色
正负代表的方向：右下(+)  左上(-) 
text-shadow: -1px 0 #000,/*为文本的四条边添加1px的实体阴影*/ /*左*/
            0 -1px #000, /*上*/
            1px 0 #000, /*右*/
            0 1px #000; /*下*/
			
text-shadow: 0 0 4px #fff,
            2px -10px 4px #ff3,
            -2px -15px 11px #f80,
            2px -25px 18px #f20;/*text-shadow阴影叠加出燃烧的文字特效*/			
4.	webstorm替换快捷键： ctrl+r
			查找快捷键： ctrl+f
			
jsp
D:\workspace\truck\truck-app\src\main\webapp\WEB-INF\module\recommendInfo\
			
http://localhost:3000/src/module/artTypeCoefficient.html  还有一个分享出去的页面！！！下周一来做

			
2017/2/20：
1.检查完善上周做的页面：
D:\workspace\truck\truck-app\src\main\webapp\appInline\static\js\page\rating.js

2.gulp环境安装：
1).先全局安装gulp:  cnpm install gulp -g
2).然后在本地安装gulp， cnpm install gulp
3).安装package里面的依赖包： cnpm install
4).执行gulp:  gulp  (其实就是执行的gulp default)
5).


2017/2/21:
D:\workSpace\truck\truck-app\src\main\webapp\tactivity\module\artSharedTyreCoefficient.html   title 改成：轮胎接单奖励

artFuelUp.js?v=169df24223


2017/2/22:

此页面（技工端邀请注册 artSendFriendsCoupon.html）与 司机端邀请注册页面（sendFriendsCoupon.html）
    已合并为同一个邀请注册页面，即：hotfix branch的regRecommand.jsp
    另外一个由此页面分享出去的然后点进来是输入号码领取优惠券的页面是 hotfix branch的recommend.jsp

../static/js/page/dirInsurance.js?v=3052017c3e	

sendFriendsCoupon.html对应regRecommand.jsp  改了html页面里的<br/> 、新增了class shareGuide1 shareGuide2 shareGuide3 shareGuide4, 替换css文件的时候，注意css里面图片的路径background:url("../img/sendFriendsCouponBtn.png")




2017/2/23:
1.把reactQa项目重新做了一遍
2. 




2017/2/24:

1.更新npm版本到最新版本：npm install -g npm
打开命令行工具 npm -version 查看是否是最新版本
如果不是 运行npm install -g npm 升级
打开C:\Users\用户名用户目录找到node_modules 文件夹下的npm文件夹，复制一份。
打开node.js 安装目录 E:\install\nodejs\node_modules，找到npm，替换为刚刚复制的那一份。
如果要使用cnpm,更新完之后需重新进行淘宝镜像安装。

2.slice and splice
[1,2,3,4,5].slice(2,4); // ==> [2,4) => [3,4] 返回被截取的数组，不会改变原来的数组。
slice() 方法可从已有的[数组]中返回选定的元素。
slice()方法可提取[字符串]的某个部分，并以新的字符串返回被提取的部分。
注意： slice() 方法不会改变原始数组。

['1','2','3','4','5'].splice(2,2,'10','0'); // 返回被删除的元素 ["3", "4"]

var num = ['1','2','3','4','5'];
num.splice(2,2,'10','0'); // arr.splice(start,deleteCount,item1,.....,itemX);
console.log(num); // => ['1','2','10','0','5'] => 会改变原来的数组

重要事项：与 slice() 和 substr() 方法不同的是，【substring() 不接受负的参数】。
所以，如果要截取倒数几位，如倒数四位，则可以用splice(-4)

关于splice有个问题：
var phone = "18380448313";
phone.splice(3,4,'*','*','*','*'); // 会报错，splice is not a function
因为splice是数组的方法，所以应该这样写：
phone.split('').splice(3,4,'*','*','*','*').join('');
或者：
或者这样写：
phone.substring(0,3)+'****'+phone.substring(7);
substring 左闭右开 [0,3)



2017/2/27：
1. vue-Meizi 简单看完了，边看边把不懂得去看了一下， 特别注重看了一下vue-router
2. js前端开发月报 2015.10


2017/2/28：
1. .babelrc文件  【注意bower安装里面用来定义下载目录的文件是 .bowerrc, 跟这个文件不一样】
{
  "presets": ["es2015", "stage-2"],  // presets 字段是用来设定转码规则 , 先下载所要使用的转码规则插件然后将其写到  .babelrc文件中
  "plugins": ["transform-runtime"],
  "comments": false,
  "env": {
    "test": {
      "plugins": [ "istanbul" ]
    }
  }
}
官网是这么说的，那些需要修改内置api才能达成的功能，譬如：扩展String.prototype，给上面增加includes方法，就属于修改内置API的范畴。这类操作就由polyfill提供。
babel-runtime 为什么适合 JavaScript 库和工具包的实现？
1).避免 babel 编译的工具函数在每个模块里重复出现，减小库和工具包的体积；
2).在没有使用 babel-runtime 之前，库和工具包一般不会直接引入 polyfill。
否则像 Promise 这样的全局对象会污染全局命名空间，这就要求库的使用者自己提供 polyfill。
这些 polyfill 一般在库和工具的使用说明中会提到，比如很多库都会有要求提供 es5 的 polyfill。
在使用 babel-runtime 后，库和工具只要在 package.json 中增加依赖 babel-runtime，交给 babel-runtime 去引入 polyfill 就行了；

总结：
具体项目还是需要使用 babel-polyfill，只使用 babel-runtime 的话，实例方法不能正常工作（例如 "foobar".includes("foo")）；
JavaScript 库和工具可以使用 babel-runtime，在实际项目中使用这些库和工具，需要该项目本身提供 polyfill；

2.vuex学习 gitbook


2017/3/2:
1.jquery判断一个元素是否存在【】
jquery判断一个元素是否存在，通过length来判断
jquery中判断一个元素dom节点是否存在,不能像js中，
if（document.getElementById('example')）,而要用到.size属性
注意，如果这个元素是display：none;的，size和length都会有值，这个时候不能这样来判断，可以用hasClass('hidden')来判断。



2017.3.3：
1.新增两个页面，先得到链接，后面图给了再修改
truckTreasureCI4.html
truckTreasureCH4.html

2.js中event的target和currentTarget的区别：【来自vue-notepad项目的event.currentTarget.nextElementSibling】
js中的event对象包含很多有用的信息
target：触发事件的元素。
currentTarget：事件绑定的元素。
两者在没有冒泡的情况下，是一样的值，但在用了事件委托的情况下，就不一样了，例如：
<ul id="ulT">
                <li class="item1">fsda</li>
                <li class="item2">ewre</li>
                <li class="item3">qewe</li>
                <li class="item4">xvc</li>
                <li class="item5">134</li>
     </ul>
　　<script type="text/javascript">
        document.getElementById("ulT").onclick = function  (event) {
            console.log(event.target);
            console.log(event.currentTarget);
        }
    </script>
结果：如果点击li，console上的情况如下：
<li class="item5">------target
<ul id="ulT">---------currentTarget

nextSibling：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。
nextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。



2017-3-6:
1.关于vue安装：
1).我们将会使用webpack去为我们的模块打包，预处理，热加载。如果你对webpack不熟悉，它就是可以帮助我们把多个js文件打包为1个入口文件，并且可以达到按需加载。
这就意味着，我们不用担心由于使用太多的组件，导致了过多的HTTP请求，这是非常有益于产品体验的。但我们并不只是为了这个而使用webpack，我们需要用webpack去编译.vue文件，
如果没有使用一个loader去转换我们.vue文件里的style、js和html，那么浏览器就无法识别。

2).模块热加载是webpack的一个非常碉堡的特性，将会为我们的单页应用带来极大的便利。通常来说，当我们修改了代码刷新页面，那应用里的所有状态就都没有了。
这对于开发一个单页应用来说是非常痛苦的，因为需要重新在跑一遍流程。如果有模块热加载，当你修改了代码，你的代码会直接修改，页面并不会刷新，所以状态也会被保留。

3).Vue也为我们提供了CSS预处理，所以我们可以选择在.vue文件里写LESS或者SASS去代替原生CSS。

4).我们过去通常需要使用npm下载一堆的依赖，但是现在我们可以选择Vue-cli。这是一个vue生态系统中一个伟大创举。这意味着我们不需要手动构建我们的项目，而它就可以很快地为我们生成。

首先，安装vue-cli。(确保你有node和npm)

npm i -g vue-cli

然后创建一个webpack项目并且下载依赖

vue init webpack vue-time-tracker
cd vue-time-tracker
npm i

接着使用 npm run dev 在热加载中运行我们的应用

这一行命令代表着它会去找到package.json的scripts对象，执行node bulid/dev-server.js。在这文件里，配置了Webpack，会让它去编译项目文件，并且运行服务器，我们在localhost:8080即可查看我们的应用。


2.npm i 只是 npm install 的简写

3.vue项目开发中去除掉Eslint验证： 在webpack.base.conf.js里面，删除掉 含有loader: 'eslint-loader' 的这一个rules即可。

4.创建另一个匿名函数强制让闭包的行为符合预期
(function(m){
	checkbox[m].onclick = function(){
		console.log(m);
	}
})(i);
或者是：
checkbox[i].onclick = function(m){
	return function(){
		console.log(m);
	}
}(i)

5.$route.path 是当前路由对象的路径，会被解析为绝对路径
for example 01:
<router-link
      v-if="$route.path !== '/time-entries/log-time'"
      to="/time-entries/log-time"
      class="btn btn-primary">创建</router-link>
for example 02:
 <ul class="nav navbar-nav">
            <li :class="{active : $route.path == '/home'}"><router-link to="/home">首页</router-link></li>
            <li :class="{active : $route.path == '/time-entries' || $route.path == '/time-entries/log-time'}"><router-link to="/time-entries">计划列表</router-link></li>
          </ul>


2017-3-8:
artRepair.html: 修改了html,css, js,images	
明天来问需求!!!!	 

2017-3-9：
接口对接：
第一个，传入名字跟电话号码到后台
$.ajax({
                type:'post',
                url: 'http://test.dadachefu.com/truck/coupon/receiveCouponLog',
				// 传json字符串对象过去
                data: JSON.stringify({
                    nickName: name,
                    phone: phone,
                    clientType: 5,
                    channelCode: 'web',
                    responseStatus: 200,
                    actionCode: 'downloadRecommend'
                }),
                dataType: 'json', /*预期服务器返回的数据类型，如果这里写了json,那么请求返回的结果res就不用再用eval转了 */
                contentType: 'application/json', /*(默认: "application/x-www-form-urlencoded") 发送信息至服务器时内容编码类型*/
                success: function(res){
                    if(res.code == 0){ // 接口请求成功
                        window.location.href = 'http://a.app.qq.com/o/simple.jsp?pkgname=com.jiajiabao.ucar';
                    }else{
                        alert(res.msg);
                    }
                },
                error: function(){

                }
            }); 
第二个，直接请求获得剩下的优惠券的数量渲染在页面上
$.ajax({
        type: 'post',
        url: 'http://test.dadachefu.com/truck/coupon/countRecommendedDownloadRecord',
        dataType: 'json',
        success: function(res){
            //var resData = eval("("+res+")");
            var resData = res;
            if(resData.code == 0){
                $restCoupons.text(resData.data);
            }
        }
    });



2017-3-10：
104.04339-----30.641982000000002
四川省, 成都市, 武侯区, 广福桥街, 14-21号

104.04339-----30.641982000000002
test2.html:108 四川省, 成都市, 武侯区, 武侯祠横街, 13号	

104.04339-----30.641982000000002

准确的：30.5524480000,104.0676850000

test2.html:35 104.052164687519-----30.638236683120883
104.052164687519-----30.638236683120883



2017-3-13:
1.baidu map api and geocoding api learning
F:\me\daily-practice\百度map api定位\Geocoding API之地址解析.html
F:\me\daily-practice\百度map api定位\Geocoding API之逆地址解析.html

2.D:\workSpace\truck\truck-web\activity\src\module\couponShare.html
D:\workSpace\truck\truck-web\activity\src\module\couponShareShow.html
D:\workSpace\truck\truck-web\activity\src\module\couponShareState.html
通过接口返回的状态，跳不同的页面，在页面url后面携带参数，如?status=1
web-activity这个branch已经提了这三个静态页面了



/*$(document).on('click', '.guideIcon img', function(){
        var _this = $(this);
        console.log($('.caption').length);
        if($('.caption').hasClass('hidden')){
            $('.caption').removeClass("hidden");
            $('.footer').css('background-color','#fff');
            _this.attr('src','../static/images/tireManagerAwardShowIcon.png');
        }else{
            $('.caption').addClass("hidden");
            $('.footer').css('background-color','#fff1c9');
            _this.attr('src','../static/images/tireManagerAwardHideIcon.png');
        }

    });*/
	
2017-3-14：
1.修改了D:\workSpace\truck\truck-web\activity\src\static\js\page\artRepair.js
D:\workSpace\truck\truck-web\activity\src\static\js\page\tireManagerAward.js 这两个页面（css js）的活动说明切换， 把click事件从原来的绑定到图片上改为了绑定到footer上。
modify the click event on artRepair.html and tireManagerAward.html
2.修改了D:\workSpace\truck\truck-web\activity\src\module\grabCouponForTyre.html 页面（html css）
fixed the click event on artRepair.html and tireManagerAward.html， modify the grabCouponForTyre.html



2017-3-15：
1.jquery ajax参数：
type: get or post, 默认是get, GET 请求中将附加在 URL 后
contentType: 默认是application/x-www-form-urlencoded 表示发送信息至服务器时内容编码。 类似的还有application/json
dataType: 预期服务器返回的数据类型。如果不指定，jquery将根据HTTP包MIME信息返回responseXML或者responseText,并作为回调函数参数传递。即function(res){}里面的res
async:默认true,默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false.注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。

2.从web-activity转战到hotfix进行开发了，把web-activity的activity文件重命名为xActivity复制到了D:\workSpace\truck\truck-app\src\main\webapp下面，以前的路径不变，新的路径会在最外面多一层路径xActivity

3.JSON与JSONP：参考 http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html， 写的很好
【说到AJAX就会不可避免的面临两个问题，第一个是AJAX以何种格式来交换数据？第二个是跨域的需求如何解决？这两个问题目前都有不同的解决方案，比如数据可以用自定义字符串或者用XML来描述，跨域可以通过服务器端代理来解决。
但到目前为止最被推崇或者说首选的方案还是用JSON来传数据，靠JSONP来跨域。而这就是本文将要讲述的内容。
 
【
	针对ajax与jsonp的异同再做一些补充说明：

1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装；

2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加<script>标签来调用服务器提供的js脚本。

3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。

4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。

总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变着一点！
】

 // 1）这里展示了jQuery如何实现jsonp的调用
                $.ajax({
                    url: 'http://api.map.baidu.com/geocoder/v2/?ak=Cu2gMKwvBltUntF3DUEZcZ6w&location=' + r.point.lat + ',' + r.point.lng + '&output=json&pois=2',
                    dataType: 'jsonp',
                    jsonp: 'callback',
                    success: function(d){
                        var result = d.result;
                        console.log(result);
                        if(result){
                            currentPosition = result.formatted_address;
                            console.log(currentPosition);
                        }else{
                            console.log('地址解析失败');
                            currentPosition = '地址解析失败';
                        }
                    },
                    error: function(d){
                        console.log('解析地址失败：' + d.msg);
                        currentPosition = '解析地址失败：' + d.msg;
                    }

                });
				
 // 2）这里展示了jQuery如何实现jsonp的调用		【jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用】	
$.ajax({
             type: "get",
             async: false,
             url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998",
             dataType: "jsonp",
             jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)
             jsonpCallback:"flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据
             success: function(json){
                 alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');
             },
             error: function(){
                 alert('fail');
             }
         });
【在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在web页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的】 		 
2）的原理是下面的代码：
<script type="text/javascript">
    // 得到航班信息查询结果后的回调函数
    var flightHandler = function(data){
        alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
    };
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
    var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&callback=flightHandler";
    // 创建script标签，设置其属性
    var script = document.createElement('script');
    script.setAttribute('src', url);
    // 把script标签加入head，此时调用开始
    document.getElementsByTagName('head')[0].appendChild(script); 
</script>		 


？？？什么是跨域？-协议、端口、域名任何一个不同即代表跨域。【参考：https://segmentfault.com/a/1190000000718840】
URL                      说明       是否允许通信
http://www.a.com/a.js
http://www.a.com/b.js     同一域名下   允许
http://www.a.com/lab/a.js
http://www.a.com/script/b.js 同一域名下不同文件夹 允许
http://www.a.com:8000/a.js
http://www.a.com/b.js     同一域名，不同端口  不允许
http://www.a.com/a.js
https://www.a.com/b.js 同一域名，不同协议 不允许
http://www.a.com/a.js
http://70.32.92.74/b.js 域名和域名对应ip 不允许
http://www.a.com/a.js
http://script.a.com/b.js 主域相同，子域不同 不允许
http://www.a.com/a.js
http://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）
http://www.cnblogs.com/a.js
http://www.a.com/b.js 不同域名 不允许

举个栗子：
我的url：http://localhost:3000/src/module/grabCouponForFuelUp.html
请求的url：http://test.hcxdi.com/truck/coupon/countRecommendedDownloadRecord 是跨域
请求的url: http://test.hcxdi.com/truck/recommend/insertRecommendLog  是跨域
 
什么浏览器允许跨域？【A上的页面获取B上的资源，浏览器会检查服务器B的HTTP头(HEAD请求)，如果Access-Control-Allow-Origin中有A，或者是通配符*，浏览器就会[允许跨域请求]。这叫CORS(跨域资源共享)】
举个栗子：http://localhost:3000/src/module/grabCouponForTyre.html页面请求这个接口：http://test.hcxdi.com/truck/coupon/countRecommendedDownloadRecord，
network中headers里面的Access-Control-Allow-Origin: * 这个就表示允许跨域。[Access-Control-Allow-Origin: Origin:http://localhost:3000 也表示允许跨域请求。]
通过jsonp跨域：在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。
CORS和JSONP对比
CORS与JSONP相比，无疑更为先进、方便和可靠。

    1、 JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。

    2、 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。

    3、 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。
	
Math.random()  === > [0,1)的随机数	



2017-3-17:
1.使用ajax时要注意的点：
1).使用get请求时，参数在url中显示，跟form表单的默认提交方式get一样，会把参数显示在url中。使用post的话，则不会显示出来。
$.ajax({
                url: src.api + '/coupon/findCouponRecordsWithCoupon',
                type: 'get',
                dataType: 'json',
                data: {
                    bill: bill
                },
				success: function(){
					
				}
});
这个例子中，type是get，这个等价于下面这个例子
$.ajax({
                url: src.api + '/coupon/findCouponRecordsWithCoupon?bill='+bill,
                type: 'get',
                dataType: 'json',
				success: function(){
					
				}
});

2).区别:
	a.get请求需注意缓存问题,post请求不需担心这个问题
	b.post请求【必须设置Content-Type值】为application/x-form-www-urlencoded
	c.发送请求时,因为get请求的参数都在url里,所以send函数发送的参数为null,而post请求在使用send方法时,却需赋予其参数

3).何时使用get,何时使用post？
Get请求的目的是给予服务器一些参数,以便从服务器获取列表.例如:list.aspx?page=1,表示获取第一页的数据
Post请求的目的是向服务器发送一些参数,例如form中的内容.
下面使用实例来表示Get请求和Post请求在发送同一段数据时的区别.
下面我们来看一个post请求：
$.ajax({
        url: src.api + '/coupon/issueCouponRecord',
        type: 'post',
        dataType: 'json',
        contentType: 'application/json',
        data: JSON.stringify({
            bill: bill, //第一个接口返回的bill
            channelCode: "web",
            clientType: getStatus('clientType'),
            orderType: getStatus('orderType')
        }),
		success: function(){
			
		}
});

4).以后给的接口，如果是[post请求]，必须要给的参数有以下几个：
第一个, dataType: 'json'
第二个, contentType: 'application/json'
第三个, data: JSON.stringify({}) 用这个转为json字符串
第四个, success函数：
success: function(res){
	var bill = res && res.data && res.data.bill; 
	// 这样写，最后获取到的值是res.data.bill. 而不是直接var bill = res.data.bill这样写，因为这样写，如果res.data.bill没有值，就会报错Cannot read property 'bill' of undefined
	var totalDiscount = res.data[i].couponRecordInfo && res.data[i].couponRecordInfo.totalDiscount;
}



2017-3-20：
1.设置透明度用rgba来设置比用opacity设置更好
RGBA比元素设置CSS的透明度更好，因为单独的颜色可以在不影响整个元素的透明度，
他不会影响到元素其他的属性，比如说边框，字体同时也不会影响到其他元素的相关透明度。
opacity后代元素会随着一起具有透明性，所以我们Opacity中的字随着透明值下降越来越看不清楚，
而RGBA不具有这样的问题，但是其支持的浏览器中有一个占在大市场份额的IE不支持，这也就是让我们需要去做兼容。
用rgba ==> background: rgba(255,255,255,.5);
用opacity ==> background-color: #fff; opacity: 0.5; filter: alpha(opacity=50);

2.FastClick消除点击延时提高程序的运行效率
引入插件的javascript文件到你的HTML网页中，像这样：
<script type='application/javascript' src='fastclick.js'></script>
注意：type属性在HTML5网页中可以省略不写。
脚本必须加载到实例化fastclick在页面的任何元素之前。
实例化 fastclick 最好在body元素的前面
$(function(){
	//fastclick用于消除在移动浏览器上触发click事件与一个物理Tap(敲击)之间的300s延迟
	FastClick.attach(document.body);
});

3.
//活动说明切换
    // 事件动态绑定到document上面在iphone上面点不开
    /*$(document).on('click', '.guideIcon img', function(){
        var _this = $(this);
        console.log($('.caption').length);
        if($('.caption').hasClass('hidden')){
            $('.caption').removeClass("hidden");
            $('.footer').css('background-color','#fff');
            $('.title').css('color','#fc3343');
            _this.attr('src','../static/images/artRepairShowIcon.png');
        }else{
            $('.caption').addClass("hidden");
            $('.footer').css('background-color','#fc3343');
            $('.title').css('color','#fbee0c');
            _this.attr('src','../static/images/artRepairHideIcon.png');
        }
    });*/
	// 修改为：
    $('.guideIcon').click(function(){
        var $img = $('.guideIcon img');
        if($('.caption').hasClass('hidden')){
            $('.caption').removeClass("hidden");
            $('.footer').css('background-color','#fff');
            $('.title').css('color','#fc3343');
            $img.attr('src','../static/images/artRepairShowIcon.png');
        }else{
            $('.caption').addClass("hidden");
            $('.footer').css('background-color','#fc3343');
            $('.title').css('color','#fbee0c');
            $img.attr('src','../static/images/artRepairHideIcon.png');
        }
    });

4. 图片垂直居中
.guideIcon {
    @include pxrem(width,108);
    @include pxrem(height,56);
    @include pxrem(line-height,56); //两个都要设置
    @include pxrem(margin, 0 auto 10 auto);
    text-align: center;

    img {
      @include pxrem(width,28);
      vertical-align: middle;  //两个都要设置
    }
}

还有一种垂直居中比较好的方法：
.demo5 {
            position: relative;
            width: 300px;
            height: 300px;
            background-color: green;
        }

        .demo5 .child {
            position: absolute;
            width: 50%;
            height: 30%;
            background-color: grey;
            margin: auto;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
        }
<!--5.Absolute Positioning and Stretching  通用，但在IE版本低于7时不能正常工作-->
    <div class="demo5">
        <div class="child"></div>
    </div>

2017-3-22：
1.关于px rem转换的问题
首先html页面首先引入<script type="text/javascript" src="../static/js/fileflex.js"></script>， 参考：https://github.com/amfe/article/issues/17 
执行这个JS后，会在<html>元素上增加一个data-dpr属性，以及一个font-size样式。JS会根据不同的设备添加不同的data-dpr值，比如说2或者3，同时会给html加上对应的font-size的值，比如说75px。
如此一来，页面中的元素，都可以通过rem单位来设置。他们会根据html元素的font-size值做相应的计算，从而实现屏幕的适配效果。
我们的页面里面，比如,设置一个： @include pxrem(width, 200px); ===> 
实际页面上渲染出来的是：（我们假设<html>根据当前设备添加的font-size=42）,那么 200 / 75 = 2.66667rem   2.66667 * 42 = 112px [computer style: 112px]	

rem是相对于根元素<html>的font-size来计算的
em首先是相对于他自己的font-size来算，如果当前对行内文本的字体未被设置，则相对于父级元素的font-size来计算	


2017-3-27：
1.把转盘的逻辑大概理清了，就等接口过来。还有，这边需要app那边传一个userId过来。


2017-3-28：
1.改一点资讯页面
2.改技工加油页面,改了


2017-3-29：
1.vue and webpack:
关于webpack，参考：Webpack 中文指南 http://webpackdoc.com/
Webpack 的特点

【Webpack 和其他模块化工具有什么区别呢？

代码拆分

Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。

Loader

Webpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。

智能解析

Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 require("./templates/" + name + ".jade")。

插件系统

Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。

快速运行

Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。】


2.vue-loader 使用 style-loader 把 component 当中的样式编译成字符串后插入到 <head> 中去。但我们希望把 css 文件独立出去，
那么可以使用上一篇文章提到的 ExtractTextPlugin 插件，配合 vue-loader 的 withLoaders() 方法实现生成独立样式文件:
// webpack.config.js
var vue = require('vue-loader')
  , ExtractTextPlugin = require("extract-text-webpack-plugin");

module.exports = {
  entry: './app.js',
  output: {
    path: './build',
    filename: 'app.js'
  },
  module: {
    loaders: [
      {
        test: /\.vue$/, loader: vue.withLoaders({
          sass: ExtractTextPlugin.extract("css!sass") // 编译 Sass
        })
      }
    ]
  },
  plugins: [
    new ExtractTextPlugin('app.css') // 输出到 output path 下的 app.css 文件
  ]
}

3.
(1).commonJS模块 [react就是用的这种模块]
服务器端的 Node.js 遵循 CommonJS规范，该规范的核心思想是允许模块通过 require 方法来[同步加载]所要依赖的其他模块，然后通过 exports 或 module.exports 来导出需要暴露的接口。
require("module");
require("../file.js");
exports.doStuff = function() {};
module.exports = someValue;
优点：
服务器端模块便于重用
NPM 中已经有将近20万个可以使用模块包
简单并容易使用
缺点：
同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的
不能非阻塞的并行加载多个模块

(2).AMD模块 [requireJS, 之前visionworks项目就是用的这种模块]
Asynchronous Module Definition 规范其实只有一个主要接口 define(id?, dependencies?, factory)，它要在声明模块的时候指定所有的依赖 dependencies，并且还要当做形参传到 factory 中，对于依赖的模块提前执行，依赖前置。
define("module", ["dep1", "dep2"], function(d1, d2) {
  return someExportedValue;
});
require(["module", "../file"], function(module, file) { /* ... */ });
优点：
适合在浏览器环境中异步加载模块
可以并行加载多个模块
缺点：
提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅
不符合通用的模块化思维方式，是一种妥协的实现

(3).ES6模块 [vue，angular2都是用的这种模块]
ES6 模块
EcmaScript6 标准增加了 JavaScript 语言层面的模块体系定义。ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。
import "jquery";
export function doStuff() {}
module "localModule" {}
优点：
容易进行静态分析
面向未来的 EcmaScript 标准
缺点：
原生浏览器端还没有实现该标准
全新的命令字，新版的 Node.js才支持
实现：
Babel

4.什么是WebPack，为什么要使用它？

为什要使用WebPack

现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法

模块化，让我们可以把复杂的程序细化为小的文件;
类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能能装换为JavaScript文件使浏览器可以识别；
Scss，less等CSS预处理器
...
这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常繁琐的，这就为WebPack类的工具的出现提供了需求。

什么是Webpack

WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。

WebPack和Grunt以及Gulp相比有什么特性

其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。

Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。




2017-3-30：
1.关于webpack讲得很好的一篇文章： http://www.jianshu.com/p/42e11515c10f#

2.下午vue 问答



2017-4-5:
1.driInsuranceFor315页面修改 
路径也换了：/xActivity/tactivity/module/driInsuranceFor315.html

2.
给老大替换"315保险"路径：
html: \truck\truck-app\src\main\webapp\xActivity\tactivity\module
css: \truck\truck-app\src\main\webapp\xActivity\tactivity\static\css
images: \truck\truck-app\src\main\webapp\xActivity\tactivity\static\images
js: \truck\truck-app\src\main\webapp\xActivity\tactivity\static\js\page

3.把vue基础看完了，明天来了再来复习，vue-router, vuex, 以及其他vue插件什么的。


2017-4-6：
1.need to do : vue插件

2017-4-10：
1.基础知识复习： $.each() 循环， html的data属性的合理利用
2.need to do, 下午：vue其他相关的插件：
vue-resource 
3.瞿通说：
dev里面的改成 HCXD.setTitle('活动详情'); 用来覆盖html里面<head>里面的<title>里面的文字。 但是现在先不慌改！！！不能改在hotfix里面。
4.vue2-happyfri分数计算有误。！！！


2017-4-11：
1.给老大替换315保险活动：
html：truck\truck-app\src\main\webapp\xActivity\tactivity\module
css: truck\truck-app\src\main\webapp\xActivity\tactivity\static\css
image: truck\truck-app\src\main\webapp\xActivity\tactivity\static\images


2.vue-chart

3.需要token的url [to 任涛]
/tactivity/module/artTyreCoefficient.html
/tactivity/module/rewardCoefficient.html
/qActivity/module/julyStatistics.html
/qActivity/module/julyStatisticsService.html
/qActivity/module/myInvitation.html

/qActivity/module/artCoefficient.html
/qActivity/module/rewardCoefficient.html
/xActivity/tactivity/module/artTyreCoefficient.html
/xActivity/tactivity/module/rewardCoefficient.html
/outside/module/share/couponShare.html
/activity/module/three.html
/activity/module/julyStatistics.html

4.分享页面：优惠券注册，优惠券领取
里程补贴
http://xapi.hcxdi.com/truck/qActivity/module/artMileage.html
加油接单奖励
http://xapi.hcxdi.com/truck/xActivity/tactivity/module/artFuelUp.html
邀请活动
http://xapi.hcxdi.com/truck/xActivity/tactivity/module/sendFriendsCoupon.html
保险活动
http://xapi.hcxdi.com/truck/xActivity/tactivity/module/driInsuranceFor315.html
优惠券介绍
http://xapi.hcxdi.com/truck/tactivity/module/couponDescription.html
轮胎接单奖励
http://xapi.hcxdi.com/truck/tactivity/module/artTyreCoefficient.html
维修厂奖励
http://xapi.hcxdi.com/truck/tactivity/module/artRepair.html
邀请加油
http://test.dadachefu.com/truck/xActivity/tactivity/module/fuelRecommendAward.html
机油ch-4
/xActivity/tactivity/module/truckTreasureCH4.html
机油ci-4
/xActivity/tactivity/truckTreasureCI4.html


5 .gitignore文件：
/truck-app/src/main/hcxdweb/node_modules
/truck-app/src/main/webapp/xActivity/node_modules
/truck-app/src/main/webapp/xActivity/cache

6.看NeteaseCloudWebApp项目代码，还没来得及看。。。

2017-4-12:
1. vue直接绑定变量给某属性
<mu-appbar :title="fname">
    <mu-icon-button icon='arrow_back' @click="back" slot="left"/>       
	<!--<div class="play-title">
            <div class="play-name"><span>{{fname}}</span></div>
    </div>-->
</mu-appbar>
data(){
	return {
		fname: "歌单"
	}
}
记住不是下面这样写的哈：
<mu-appbar :title="{{fname}}">  <--错误写法-->
    <mu-icon-button icon='arrow_back' @click="back" slot="left"/>       
	<!--<div class="play-title">
            <div class="play-name"><span>{{fname}}</span></div>
    </div>-->
</mu-appbar>

2017-4-13：
1.-webkit-filter:none | blur(px) | brightness() | contrast() | grayscale() | hue-rotate(deg) | invert() | opacity() | saturate() | sepia() | drop-shadow( radius )| url()
blur(<number>px)	设置对象的模糊效果。
for example:
.bg-player{
	background-image: url(http://p1.music.126.net/pzwuL0a4DFvQcEJRqQfTYw==/109951162901875051.jpg?param=300y300);
	width: 400px;
	height: 300px;
	filter: blur(40px);
	-webkit-filter: blur(40px);
	background-size: cover;
    background-position: bottom right;
}

return _baseUrl + '?type=topPlayList&cat=' + cat + '&offset=' + offset + '&limit=' + limit
http://musicapi.duapp.com/api.php?type=topPlayList&cat=全部&offset=0&limit=6

_baseUrl2 + '?type=playlist&id=' + id
https://api.imjad.cn/cloudmusic/?type=playlist&id=630863306

_baseUrl + '?type=url&id=' + id
http://musicapi.duapp.com/api.php?type=url&id=188556

2.Vue 原本有一个官方推荐的 ajax 插件 vue-resource，但是自从 Vue 更新到 2.0 之后，官方就不再更新 vue-resource
目前主流的 Vue 项目，都选择 axios 来完成 ajax 请求，而大型项目都会使用 Vuex 来管理数据，所以这篇博客将结合两者来发送请求
安装其他插件的时候，可以直接在 main.js 中引入并 Vue.use()，但是 axios 并不能 use，只能每个需要发送请求的组件中即时引入
为了解决这个问题，有两种开发思路，一是在引入 axios 之后，修改原型链，二是结合 Vuex，封装一个 aciton。
首先在 main.js 中引入 axios
import Axios from 'axios'
这时候如果在其它的组件中，是无法使用 axios 命令的。但如果将 axios 改写为 Vue 的原型属性，就能解决这个问题
Vue.prototype.$http = Axios // 类似于vue-resource的调用方法，之后可以在实例里直接用this.$http.get()等
在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 $http.get() 命令
Axios.get(api.getSong(id)).then(res => {
        // 统一数据模型，方便后台接口的改变
        var url = res.data.data[0].url
        commit('setAudio')
        commit('setLocation', url)
      })
      .catch((error) => {     // 错误处理
        console.log(error)
        window.alert('获取歌曲信息出错！')
      })
	  
当我们ajax获取数据成功后会返回一个response对象，它包含了以下内容：
{
  // `data` is the response that was provided by the server
  data: {},

  // `status` is the HTTP status code from the server response
  status: 200,

  // `statusText` is the HTTP status message from the server response
  statusText: 'OK',

  // `headers` the headers that the server responded with
  headers: {},

  // `config` is the config that was provided to `axios` for the request
  config: {}
}	
所以，response.data.data.msg  
3.
大转盘活动需求：
1）进入抽奖页面，如果当前用户是认证失败的，则弹出“认证失败”。
2）点击“开始抽奖”按钮，判断当前用户是否完成认证，如果没有，则弹出“赶紧去认证”。
如果当前用户认是证失败的，（可能刚进app的时候就弹出来了，但是用户又把弹框关了），那就弹出“认证失败”弹框。
如果是已经认证成功的，则可以进行抽奖

4.点击某一首进行播放，最下面的document.getElementById('audioPlay').pause()是怎么出来的？？？
5.HTML5中的<time>标签:
<p>我们在每天早上 <time>9:00</time> 开始营业。</p>


2017-4-14：
补胎券：60
200元大礼包：120
再来一次： 180
机油：240
小米：300
iphone: 360


按照瞿通的意思就是，要把hotfix的分支删了，以dev分支为准，hotfix上面活动相关的删了。
下周来了应该就是在dev分支去开发了，hotfix分支4.0之后就不再用了，把hotfix分支新改动的拷贝出来，放在dev分支去，以后就在dev分支上面开发了，hotfix就不再用了。


2017-4-17：
1.D:\workSpace\truck\truck-app\src\main\webapp\hcxdweb\src\components\driInsuranceUpload\upload.vue

//fastclick用于消除在移动浏览器上触发click事件与一个物理Tap(敲击)之间的300延迟
    FastClick.attach(document.body);
	
2. 瞿通写的vue代码里面：
(1).
import {
    Indicator,
    Toast
} from 'mint-ui';
mint-ui是基于vue.js的移动端组件库 [http://mint-ui.github.io/docs/#!/zh-cn2]，其中：
Indicator：js components 加载提示框，支持自定义文本和加载图标。
Toast: js components 简短的消息提示框，支持自定义位置、持续时间和样式。

(2). rootSrc.link and rootSrc.api, rootSrc对象定义在hcxdweb\src\assets\js\common\config.js里面。

(3). vue class 绑定：
<p id="register" @click="getPackage" class="receiveSpreeBtn jq-receive-btn" :class="{receiveSpreeBtnActive: codeOk}">领取大礼包</p>

3.vue-router路由信息对象的属性：【http://router.vuejs.org/zh-cn/api/route-object.html】
$route.path
类型: string
字符串，对应当前路由的路径，总是解析为绝对路径，如 "/foo/bar"。

$route.params
类型: Object
一个 key/value 对象，包含了 动态片段 和 全匹配片段，如果没有路由参数，就是一个空对象。

$route.query
类型: Object
一个 key/value 对象，表示 URL 查询参数。例如，对于路径 /foo?user=1，则有 $route.query.user == 1，如果没有查询参数，则是个空对象。

$route.hash
类型: string
当前路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串。

receiveSpree.js:
// 新增电话号码超出验证
phone.on('keyup', function(){
		var phoneVal = $(this).val();
		if($(this).val().length > 11){
			$(this).val(phoneVal.substring(0,11));
		}
	});
或者可以给phone的input加一个 maxlength="11"



2017-4-19：
文字重新更订一下：
9.9元补胎券：60
200元大礼包：120
再来一次： 180  （这个度数你写成了108，逗比）
货车宝机油：240
小米充电器：300
iphone: 360


{"code":0,"data":{"createTime":1492139230000,"id":2,"name":"200元大礼包","position":120,"probability":0.200000,"quantity":98,"type":3},"msg":"","serverTime":1492583588277}
{"code":0,"data":{"createTime":1492139501000,"id":4,"name":"机油","position":240,"probability":0.100000,"quantity":1,"type":1},"msg":"","serverTime":1492584923858}
{"code":0,"data":{"createTime":1492139540000,"id":5,"name":"小米","position":300,"probability":0.100000,"quantity":10,"type":1},"msg":"","serverTime":1492586235285}
{"code":0,"data":{"createTime":1492139303000,"id":3,"name":"再来一次","position":108,"probability":0.500000,"quantity":999999996,"type":0},"msg":"","serverTime":1492583814970}
{"code":1,"msg":"没有抽取机会了","serverTime":1492584019109}


2017-4-20:
1.大转盘活动，还需要: 
第一，小艾修改接口，res.code ； 
第二，客户端写一个方法，“HCXD。重定向到认证页面”； 
第三，分享出去的页面，两个接口，第一个，获取验证码(已有)，第二个，注册用户（已有： /userDriver/public/register ？）


2017-4-24:
1.js基础复习
2.司机端技工端专用机油切图


2017-4-25：
司机端技工端专用机油
司机端：/xActivity/tactivity/module/driEngineOilGuide.html
技工端：/xActivity/tactivity/module/artEngineOilGuide.html


2017-4-26：
1.把大转盘的未认证和认证失败的弹框修改了。
2.


2017-4-27:
1.background-size: cover 和 contain的区别：
不同之处在于：
1).  在no-repeat情况下，如果容器宽高比与图片宽高比不同，
cover：图片宽高比不变、铺满整个容器的宽高，而图片多出的部分则会被截掉；
contain:图片自身的宽高比不变，缩放至图片自身能完全显示出来，所以容器会有留白区域；
PS:其实，从英文的意思来说：cover意味着“遮罩、遮盖”---此处理解为“塞满”较恰当，contain意为“包含”--也就是：我图片虽然缩放了，但是整个图是被“包含”在你里面的，你必须把我显示完整、不能裁剪我一丝一毫~
2).  在repeat情况下：cover:与上述相同；contain:容器内至少有一张完整的图，容器留白区域则平铺背景图，铺不下的再裁掉。

2.webSocket?
polling(轮询) and long polling(长轮询、推送)：
服务端推送技术应用越来越普遍，应用范围也越来越宽广，技术解决方案也越来越成熟且丰富。很多SNS网站的chat功能就有用到了Long Polling技术。比如fackebook, kaixin001。

Long Polling原理其实很简单，也很讨巧。与Polling相比，Long Polling客户端也许不会马上收到来自服务端的响应，需要等待一些时间(直到有新消息，或者连接timeout了等等)。同样的，客户端也不再需要定时向服务发送请求了，而是直到收到服务端响应之后，或者连接丢失之后，客户端接着马上请求客户端。

这里，我打个比方，传统的Polling一般是由C向S询问：“有我的信件吗？”。S接到询问之后，会立即查询，并且把查询结果告诉C，不管有没有C的信件，要么回复：“嗯，你有X封信。”，要么回复：“没，没有你的信”。

而Long Polling更像是这样，C向S发出询问：“有我的信件吗？”，S开始查询，如果有则回复C：“嗯，有你x封信”。如果没有，则不作任何回复，而是让C等着，自己一遍一遍地查询是否有订阅者的信。

换句话说：当S收到C的查询请求之后，Polling则只查询一次，并且把查询结果告诉C;而Long Polling收到请求之后，则会一遍一遍地查询，直到有消息才会响应C，不然一直hold Client。

Long Polling相较传统的Polling而言，最大的实惠在于：减少了请求次数。举个例子，假定一个用户每2小时内，有可能收到2条新消息。如果采用传通的Polling方式，每30秒发向服务端发送一次查询请求的话。则在这2小时内，服务器需要处理240(60*60*2/30)次请求，其中至少有238次请求是没有实际意义的。试想，如果是10000的并发量的话，这种浪费是很惊人的。相较而方，Long Polling没有那么浪费服务器资源来处理这些没有实际意义的请求。


2017-4-28：
atg_store_catSubNv jq-navigation-subNav



2017-5-2：
1.


2017-5-8：
1.大转盘的代码： hotfix上面还是之前测试时候改的代码，今天该邀请注册的时候被覆盖了，一定记得！！！


2017-5-9:
第一.总结：
1.大转盘的问题，最开始以为是代码逻辑或者接口有问题，后来发现其实是ios里面，对alert()方法的不兼容，这个我也觉得很奇怪。后来改用的是app内置的HCXD.toast()方法就可以了。
这个问题，后来查明了，iphone里面都不支持alert，ios分为uiwebview和wkwebview，我们可以理解为直接打开的没有经过修改的wkwebview不支持alert。
2.邀请注册分享出去的页面，今天第一个问题是，input和=输入框在ios上面不能获取焦点，但是已经启动了输入框。查资料显示是：
移动端webview中写页面的时候发现个别Android和iphone机型会导致input、textareat输入框无法输入（键盘可以弹起，不是webView.requestFocus(View.FOCUS_DOWN);的问题）
出现这个的原因是，之前我们做大转盘的时候，在点击转按钮的时候，会出现图片阴影，然后我们就给他加了个
* {
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
}
然后，经过试错发现是-webkit-user-select:none;所导致的原因，当然如果你确实需要这个-webkit-user-select这个属性，css初始化代码改写为如下即可：
* {
-webkit-box-sizing: border-box;
-moz-box-sizing: border-box;
box-sizing: border-box;
-webkit-tap-highlight-color: transparent;
outline: none;
}
*:not(input,textarea) { 
-webkit-touch-callout: none; 
  -webkit-user-select: none; 
}
3.邀请注册分享出去的页面，后来又出现一个问题，就是不能注册，后来，原因就是我把接口的域名什么的path写死了，写成测试服的了。妈的，智障！！！


2017-5-10：
1.昨天下班的时候跟陈然提起了那天晚上我们几个人测试了很久的问题。大转盘活动，在电脑上跑起来访问，同时在手机上访问，电脑上总是走success里面，手机上总是走error里面。
经陈然偶然提起，好吧，真的是跨域的问题，因为我电脑上chrome浏览器进行了跨域的设置。所以，那一晚上在干嘛，我也不知道，我不敢跟老大说，我怕他打我！！！哈哈哈。



2017-5-11：
1.
import NProgress from 'nprogress'
import 'nprogress/nprogress.css'

// 路由跳转有progress，加在vue-router的beforeEach和afterEach中
router.beforeEach(() => {
  NProgress.start()
})
router.afterEach(() => {
  NProgress.done()
})

2.任涛那边给方法：【等他们发版之后就可以用了】
var currentLocation = HCXD.getLocation();
currentLocation = {
	location: {
		lat: 30.67994271991261, // 纬度坐标
		lng: 104.06792345999995 // 经度坐标
	},
	addressComponent: {
		adcode: "510105",  // 行政区划代码【取不到】
		city: "成都市",  // 城市名
		country: "中国",  // 国家
		district: "青羊区",  // 区县名
		provience: "四川省",  // 省名
		street: "王家塘街",  // 街道名
		street_number: "84号"  // 街道门牌号
	},
	formatted_address: "四川省成都市青羊区王家塘街84号",  // 结构化地址信息
	cityCode: 75   // 城市id
}
console.log(HCXD.getLocation()); // 得到的是json字符串，要记得转一下


3.http://test.dadachefu.com/activity/findTop100UserPrizes?userId=19475  这个接口报错502，记得看一下原因！！！


2017-5-16:
1.替换路径：
html:
\truck\truck-app\src\main\webapp\xActivity\tactivity\module
js：
\truck\truck-app\src\main\webapp\xActivity\tactivity\static\js\page

2.切换到dev去开发， hotfix分支的还是之前的内容【大转盘没有修缮前的代码，记得最后的最后一起提一下哦】


2017-5-17:
1.vue项目运行报错：
 component lists rendered with v-for should have explicit keys.
原因： In 2.2.0+, when using v-for with a component, a key is now required.
for example:
<my-component v-for="item in items" :key="item.id"></my-component>

2.json对象与json字符串的区别？



2017-5-18:
1.vue router编程式导航：
2.vue watch用法


2017-5-19：
1..$route.query and $route.params
2. axios
3.有个问题，在项目里面用了nprogress，就不能切换router了，卡住了，这是什么原因，之前也遇到过！！！！
已经可以了，这样在main.js里面使用：
router.beforeEach((to, from, next) => {
  NProgress.start()
  next()
})
router.afterEach(() => {
  NProgress.done()
})


2017-5-23:
1.angular-tour-of-heroes 项目参考教程重新做了一遍。
2.打算用vue把这个项目也做一遍
最后： 搜索筛选功能还没做！！！

2017-5-24：
1. vue-tour-of-heroes完成


2017-5-25：
1.my-houtai 
渲染活动列表，查看详情
发布活动，存在本地！（明天来做）

2017-5-26：
发布活动，时间处理！


2017-5-27：
1.angular,react,vue对比：
react的redux 跟 vue 的vuex类似，都是store
如果你的应用有以下场景，可以考虑使用 Redux:
某个组件的状态，需要共享
某个状态需要在任何地方都可以拿到
一个组件需要改变全局状态
一个组件需要改变另一个组件的状态
对比：
1).模块使用不同，vue 和 angular2用的是ES6模块；react使用的是commonJS模块。


2017-6-5：
1.bootstrap优缺点？
优点：
1). 栅格系统(结构)。
bootstrap的优势之一是可以根据用户屏幕尺寸调整页面，使其在各个尺寸上都表现良好。
实现这个东西依赖两个东西，一个是view, 一个是max-width, min-width。
bootstrap栅格系统的本质就是通过CSS3的媒体查询实现的。
这里要特别提一下的就是BT的盒模型，BT强制把所有元素的盒模型都设置成了border-box，这是IE首创的，
用于混杂模式下显示网页，但W3C认为这个属性是个逗逼一直没采用，但最后发现自己才是逗逼，因此在CSS3
中新增了这个属性。border-box盒模型的尺寸包含了padding+border+content ，content-box盒模型的尺寸仅
仅包含content部分，设置padding，border还的重新计算包含块尺寸，使用上要比border-box麻烦的多。
2). css模块化(表现)
BT预先定义了很多CSS类，使用的时候直接给class赋予对应的类名即可，如text-left，text-align，.table等。
最有代表性的就是btn类，BT定义了一个.bt的基础类，如果还想要其他样式可以在这个基础类上进行扩展，实现不同的视觉效果。
.btn类之所以典型在于他的样式定义，CSS大牛和菜鸟的区别表现在三个方面，文件大小，后期维护以及hack，
大牛的CSS文件都比较小（具体多少为小要看项目的大小）；后期维护容易，能快速定位，修改一个样式需要动的地方比较少；
hack使用也少。相反菜牛则会出一个庞大的文件，后期维护一团乱麻，改一个样式需要改很多地方，hack，内联，important满天飞。
CSS很多值都是有相互依赖关系的，比如em，我们都知道em是相对单位，浏览器渲染的时候是必须明确到具体值的，因此必须进行计算。
正因为这些相对单位我们才可以实现模块化，.btn类就是利用相对单位和字体大小之间的关系实现的，
将按钮的line-height设置为相对单位，字体大小，padding，border-radius设置为绝对单位，需要大按钮的时候增加字体，需要小按钮的时候减小字体
3). javascript插件(交互)。
BT的JavaScript插件非常丰富，既可以用现成的也可以自己扩充，BT提供了一个集成板的BT.js您可以直接拿过来使用也可以单个使用引入*.js即可。
JS插件优秀的地方在于，哪怕是不懂JS的开发人员也可以使用，只要按照官方文档提供的格式写即可，比如模态框，您只要按要求设置好class，data-toggle，data-target即可，一句JS都不用写，是不是很方便。
BT的插件开发模式基本都是相似的，先定义一个类，实现主体功能，然后是个Plugin函数，再把这个函数扩展到JQuery原型上，最后通过委托的方式给特定元素绑定事件。

缺点：
对IE兼容也存在不小的问题，BT将所有的元素盒模型都设置成了border-box，这是IE混杂模式下的盒模型，光这点就导致了不能兼容IE。
此外还用到了大量的H5标签以及CSS3语法，这些语法标签兼容性方面同样存在不小的问题，当然网上存在很多兼容IE的办法，但需要引入其他文件，有些还不小，势必导致加载速度变慢，影响用户体验。
BT对IE6，7的兼容性肯定不好，对IE8的支持也需要一些额外的文件。
IE8的媒体查询需要response.js的配合才能实现
BT 不支持 IE 古老的兼容模式。为了让 IE 浏览器运行最新的渲染模式下，建议将此 <meta> 标签加入到你的页面中：
<meta http-equiv="X-UA-Compatible" content="IE=edge">
按 F12 键打开 IE 的调试工具，就可以看到 IE 当前的渲染模式是什么。


2.js前端开发月报，五月份的记得看

3.git 仓库迁移了，修改本地工程目录下.git/config文件，修改url = dada@dada@114.55.73.189:~/git/项目名称.git ---> url = git@120.26.10.20:~/项目名称.git



2017-6-7:
javascript模块规范： 目前，通行的Javascript模块规范共有两种：CommonJS和AMD

CommonJS模块规范： 【服务端的规范】
node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。
假定有一个数学模块math.js，就可以像下面这样加载。
　　var math = require('math');
然后，就可以调用模块提供的方法：
　　var math = require('math');
　　math.add(2,3); // 5
由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。
第二行math.add(2, 3)，在第一行require('math')之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。
这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。
但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于"假死"状态。
因此，浏览器端的模块，不能采用"同步加载"（synchronous），只能采用"异步加载"（asynchronous）。这就是AMD规范诞生的背景。

AMD模块规范：
AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。
所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。
AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：
　　require([module], callback);
第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：
　　require(['math'], function (math) {
　　　　math.add(2, 3);
　　});
math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。
目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js。

CMD模块规范：
关于这个规范呢玉伯在知乎是这么说的
”AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。"
所以这个规范实际上是为了Seajs的推广然后搞出来的。那么看看SeaJS是怎么回事儿吧，基本就是知道这个规范了
同样Seajs也是预加载依赖js跟AMD的规范在预加载这一点上是相同的，明显不同的地方是调用，和声明依赖的地方。
AMD和CMD都是用difine和require，但是CMD标准倾向于在使用过程中提出依赖，就是不管代码写到哪突然发现需要依赖另一个模块，
那就在当前代码用require引入就可以了，规范会帮你搞定预加载，你随便写就可以了。
但是AMD标准让你必须提前在头部依赖参数部分写好（没有写好？ 倒回去写好咯）。这就是最明显的区别。




//===10.25日之前文件丢失，我心好痛===//
四川弱密码修改：
// 密码验证（要求密码必须8位非空白字符（空白字符：\t, \n, \r, \f, \v），且要包含字母或符号）
    function pwdValidate(password) {
        var pattern = /[\S]{8,}?/g; // 所有非空白字符 长度>=8
        if (pattern.test(password)) {
            password = password.replace(/\d/g, '');
            return (/[\S]+?/g).test(password); // 去掉数字干扰，然后判断是否包含字母或符号
        }
        return false;
    }
	解释：\S 匹配所有非空白，而 \w 只匹配单词字符，等价于 [a-zA-Z0-9_] 共63个字符（字母数字下划线）
		  + : 一次或多次
		  * : 零次或多次
		  ? : 零次或一次

正则表达式：
\s是指空白，包括空格、换行、tab缩进等所有的空白；
而\S刚好相反这样一正一反下来，就表示【所有的字符，完全的，一字不漏的】。
正则表达式中test()方法的用法：
objReg.test(objStr); 
// objReg 必选项 RegExp对象名称
// objStr 要进行匹配检测的字符串


2017-10-25:
1.周报： D:\workspace\GovSupervisionPlatform\Trunk\Common\Docs\00 项目\05-项目周报
代码审查： D:\workspace\GovSupervisionPlatform\Trunk\Common\Docs\04 开发\03代码审查
2.本地用这个ip,更快一些： 10.50.75.102
3.在检查一下，改报表
最高限速   最高速度
4.修改了山西运城首页的一些东西

2017-10-26:
1.移动端websocket完成
2.山西运城网约车权限看到单独的网约车页面

2017-10-27：
1.四川线上新哥账号： test_wjx  wjx520366
2.796环比同比数据绑定（发现一个查询）
3.山西太原首页左上角接入平台监管模块之前由于市级权限被隐藏了

2017-10-31：
1.box-sizing: border-box; (怪异模式) 这样就是为了在设置有padding和border的时候不把宽度撑开。
ie盒模型对应的就是box-sizing: border-box;
w3c和模型就是对应的box-sizing: content-box; (默认值)

2017-11-1:
做websocket服务需要改到的几个文件：
1.WSData.js: 定义命令
SUBCMD_YUNWEI_Minitor: 322          // 服务监控

2.WS.js: 定义结构体（定义内容的长度、类型等等）
// 服务监控
  struct.YUNWEI_Minitor = function () {
    this.content = {
      value: 0,
      type: nType.String.name,
      length: 400,
      isEncode: true
    };
  };

3.WebSocketPartial.js: 利用子命令和结构体，定义事件名称
// 服务监控
    case WSData.Subcmd.SUBCMD_YUNWEI_Minitor:
      struct = new WSData.Struct.YUNWEI_Minitor();
      data = getResponseData(struct, head, reader);
      //console.log(data)
      eventName = "YunWei_Minitor";
      break;

4.然后在js里面这样使用：
Gov.getWSThread().on({
          bag: "YunWei_Minitor",
          reply: function (data) {
            var ret = data.data.response.content;
            console.log(ret);
          }
        });

		
2017-11-2：
1.websocket前端发送消息给后端：（vehicle.js）
	setVehicleTrack: function (data, fn) {
		if (!Gov.getWSThread().getWsState()) return;
        var obj = new Gov.WS.Struct.VehicleTrack(); // WS.js
        var wsObj = obj.getWSObject();
        wsObj.sourceH = sessionStorage.userId;
        wsObj.deviceH = data.id;
        wsObj.featureH = data.type;
        Gov.getWSThread().sendMessage({
            bag: obj.toString(),
            data: wsObj,
            reply: function (data) {
                Gov.Pages.Monitor.map.queueShift1();
                Gov.Pages.Monitor.map.removeAllMarker();
                Gov.Controls.ObjectArtDialog.msg("跟踪设置成功,正在准备数据...", 6);
                fn && fn(); // 执行回调函数
            }
        });
        Gov.Controls.SaveLogs({ Type: 4, Operation: "跟踪车辆" });
    },
    setVehicleCancelTrack: function (fn) {
        if (!Gov.getWSThread().getWsState()) return;
        var obj = new Gov.WS.Struct.VehicleCancelTrack();
        var wsObj = obj.getWSObject();
        wsObj.sourceH = sessionStorage.userId;
        Gov.getWSThread().sendMessage({
            bag: obj.toString(),
            data: wsObj,
            reply: function (data) {
                Gov.Pages.Monitor.map.queueShift();
                Gov.Pages.Monitor.map.removeAllMarker();
                Gov.Controls.ObjectArtDialog.msg("已取消跟踪", 6);
                fn && fn();
            }
        });
        Gov.Controls.SaveLogs({ Type: 4, Operation: "取消跟踪车辆" });
    }
	
	
Baseinfo_platform_update_synchro
	
2.ES6 对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。
// 正确返回字符串长度的函数：
	function codePointLength(text){
		var result = text.match(/[\s\S]/gu);
		return result ? result.length : 0;
	}
	var s = "hello world!";
	console.log(s.length); // 12
	var s2 = "𠮷𠮷";
	console.log(s2.length); // 4  这个不对
	console.log(codePointLength(s2)); // 2  这个才正确
\s是指空白，包括空格、换行、tab缩进等所有的空白；
而\S刚好相反这样一正一反下来，就表示【所有的字符，完全的，一字不漏的】(\S 匹配所有非空白)。

3."^abc$": 匹配以abc开头和以abc结尾的字符串，实际上是只有abc与之匹配
所以验证数字的正则是： var rule = /^[0-9]*$/;
验证n位的数字： var rule = /^\d{n}$/;
验证至少n位数字： var rule = /^\d{n,}/;
验证m-n位的数字： var rule = /^\d{m,n}/;

2017-11-3：
1.js删除一个对象的某个属性, 用delete obj[key]
			var vehicleTypeObj = {
                dbName: "VehicleType",
                showName: "VehicleType",
                label: "车辆类型",
                mustChoose: true,
                isMultiselect: false
            };
            if (isNotes) {
                vehicleTypeObj.disabled = true;
            } else {
                if (vehicleTypeObj.disabled) {
                    delete vehicleTypeObj.disabled; // 这样用
                }
            }
			
2017-11-6:
1.内蒙车辆修改，要求几个字段不可以编辑，text文本（输入文本框）的根据封装的直接添加readOnly属性即可，
但是select下拉框本身就是readOnly（只可选择不可输入的），但是在编辑的时候也要达到相应的不能修改该字段的值，
所以重写了Gov.Control.Select组件，添加了一个disabled属性，并且该属性只在disabled=true的时候才添加到input上面。
【这里这样做了，就可以不用在页面上delete了，因为我只在disabled=true的时候才添加了一个disabled="true"到input上面， 如： <input disabled="true"/>, 
false的时候并没有添加disabled属性到input上面， false的时候就只有这样：<input/>】
内蒙：BaseIfo/Vehicle.js:
var vecType16Obj = {
                dbName: "VehicleType",
                selItems: [
                    { name: "三类以上班线客车", val: 0x20080000 },
                    { name: "高速客车", val: 0x08080000 },
                    { name: "超长客车", val: 0x01080000 },
                    { name: "旅游客车", val: 0x02080000 },
                    { name: "包车客车", val: 0x10080000 },
                    { name: "危险品运输车", val: 0x00100000 },
                    //{ name: "重型货物运输车", val: 0x40001 },
                    //{ name: "半挂牵引车", val: 0x40020 },
                    { name: "普通货车", val: 0x40000 },
                    { name: "农村客运", val: 0x04080000 },
                    { name: "驾培车", val: 0x400000 },
                    { name: "出租车", val: 0x800000 },
                    { name: "公交车", val: 0x10000 },
                    { name: "租赁客车", val: 0x00081000 },
                    { name: "校园车辆", val: 0x40000 },
                    { name: "其他车", val: -1 }
                ],
                showName: "VehicleType",
                label: "车辆类型",
                mustChoose: true,
                isMultiselect: false
            };
            if (isNotes) {
                vecType16Obj.disabled = true;
            } else {
                if (vecType16Obj.disabled) {
                    delete vecType16Obj.disabled;
                }
            }
            var vecType16 = Gov.Control.Select(vecType16Obj);
这里特别要注意的一点是：只要有disabled属性，不管值是true or false, 
都会被disabled掉，这里就有个移除js对象的某个属性，用delete obj.disabled;
NOTICE: 
1.只要存在disabled属性，不管是true还是false，都会被disabled掉！
2.只要存在readOly属性，不管是true还是false，都会使文本框变成只可读！
3.select下拉选择框，要设置成不能选的话，只能设置disabled属性，readOnly属性不起作用，因为select默认就是只可读不可写的！
4.readOnly和disabled区别：
	1).disabled会被置灰，readOnly不会; <br/>
	2).使用tab聚焦，readOnly可以，disabled不可以;<br/>
	3).当提交表单时，disabled的这个表单输入项将不会被提交，readOnly会作为form表单的一项进行提交<H3>

	
2017-11-7：
1.山西省下面的各个市（太原、大同、晋中等等）做静态信息配置表（StaticInfoConfig.js）[其实就相当于是定义属于window的全局变量，可以看到有下面这样一段代码：]
(function($){
	$.StaticInfoConfig = $.StaticInfoConfig == null ? {} : $.StaticInfoConfig;
	var staticInfoConfig = {
		taiyuan: {
            province: "太原市",
            mapCenterCity: "太原市",
            loginTitle: "太原市重点营运车辆<br/>联网联控系统",
            mainTitle: "太原市重点营运车辆联网联控系统",
            subMainTitle: "太原市重点营运车辆联网联控系统",
            footerContent: "航天科技控股集团山西有限公司 Copyright © 2005 - " + new Date().getFullYear()
        }
	};
	// 当前配置
    var currentConfig = staticInfoConfig.taiyuan;

    var province = currentConfig.province,
        mapCenterCity = currentConfig.mapCenterCity,
        loginTitle = currentConfig.loginTitle,
        mainTitle = currentConfig.mainTitle,
        subMainTitle = currentConfig.subMainTitle,
        footerContent = currentConfig.footerContent;

    $.StaticInfoConfig.getProvince = function () {
        return province;
    };
    $.StaticInfoConfig.getMapCenterCity = function () {
        return mapCenterCity;
    };
    $.StaticInfoConfig.getLoginTitle = function () {
        return loginTitle;
    };
    $.StaticInfoConfig.getMainTitle = function () {
        return mainTitle;
    };
    $.StaticInfoConfig.getSubMainTitle = function () {
        return subMainTitle;
    };
    $.StaticInfoConfig.getFooterContent = function () {
        return footerContent;
    };
})(function(){
	var $;
	try {
		$ = window;
	}
	catch(e){
		$ = this;
	}
	return $;
}()); 
然后在其他页面引用这个文件，就可以像下面这样使用啦：
$('.home-footer > p').text(StaticInfoConfig.getFooterContent()); // footer
//这里代码注入的参数只有window, 同样的还可以注入jQuery等参数，例如：
(function($, jq){
	$.StaticInfoConfig = $.StaticInfoConfig == null ? {} : $.StaticInfoConfig;
	$.StaticInfoConfig.getDomById = function(id){
		return jq('#' + id);
	};
})(function(){
	var $;
	try {
		$ = window;
	}
	catch(e) {
		$ = this;
	}
	return $;
}(), function(){
	try {
		return jQuery;
	}
	catch (e) {
		return null;
	}
}());

2017-11-8：
1.c#类学习：
1).对象是类的实例。构成类的方法和变量成为类的成员。
// 申明一个class_name类
<access specifier> class class_name {
	// 1.member varibles
	<data type> variable1;
	<data type> variable2;
	...
	<data type> variableN;
	
	// 2.member methods
	<access specifier> <return type> method1(parameter_list){
		// method body
	}
	....
	<access specifier> <return type> methodN(parameter_list) 
    {
        // method body 
    }
}
<access specifier>: 访问标识符
类的默认访问标识符是：internal
成员的默认访问标识符是：private
要访问类的成员，使用（.）标识符
2).类的构造函数是类的一个特殊的成员函数，当创建类的新对象时执行。
构造函数的名称与类的名称完全相同，它没有任何的返回类型。例子：
using System;
namespace BLL.Reports{
   public class VehicleInstallZone:BaseReports<ZoneMPar>{ 
       public VehicleInstallZone(StrucReportInfo rInfo, string model) : base(rInfo, model) { // 构造函数
        }
       protected override DataSet GetDataSet(){
           IDAL.IVehicleInstall iOver = DALFactory.Factory.CreateVehicleInstall();
           return iOver.GetDataByZone(this.ModelParame);
       }
    }
}
默认的构造函数没有任何参数，但是如果你需要一个带有参数的构造函数的话，就可以有，这种构造函数叫做参数化构造函数。
一个类里面的Main函数是类的入口函数：
class Line
   {
      private double length;   // 线条的长度
      public Line(double len)  // 参数化构造函数
      {
         Console.WriteLine("对象已创建，length = {0}", len);
         length = len;
      }

      public void setLength( double len )
      {
         length = len;
      }
      public double getLength()
      {
         return length;
      }

      static void Main(string[] args)
      {
         Line line = new Line(10.0);
         Console.WriteLine("线条的长度： {0}", line.getLength()); 
         // 设置线条长度
         line.setLength(6.0);
         Console.WriteLine("线条的长度： {0}", line.getLength()); 
         Console.ReadKey();
      }
   }
3).c#继承
继承是面向对象程序设计中最重要的概念之一。当创建一个类的时候，不需要重新编写新的数据成员和成员函数，只需要设计一个新的类，继承已有的类的成员即可。
这个已有的类叫做基类，新的类叫做派生类。继承的思想实现了属于（IS-A）关系。
public class VehicleInstallZone:BaseReports<ZoneMPar>{ // VehicleInstallZone: 派生类   BaseReports：基类

}
c#不支持多重继承，但是可以使用接口（interface）来实现多重继承
class Shape() {}
public interface PainCost(){} // 基类PainCost
class Rectangle : Shape, PaintCost { } // 派生类
class RectangleTester {
	static void Main(string[] args){
		Rectangle Rect = new Rectangle();
		int area;
		Rect.setWidth(5);
		Rect.setHeight(7);
		area = Rect.getArea();
	}
}
4).c#多态性
多态意味着有多种形式。在面向对象编程编程中往往表现为“一个接口，多个功能”
	1).静态多态性：c#提供了两种技术来实现静态多态性，分别是： 函数重载； 运算符重载；
什么是函数重载？你可以在同一个范围内对相同的函数名有多个定义。函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同。不能重载只有返回类型不同的函数声明。
class Printdata
   {
      void print(int i)
      {
         Console.WriteLine("Printing int: {0}", i );
      }

      void print(double f)
      {
         Console.WriteLine("Printing float: {0}" , f);
      }

      void print(string s)
      {
         Console.WriteLine("Printing string: {0}", s);
      }
      static void Main(string[] args)
      {
         Printdata p = new Printdata();
         // 调用 print 来打印整数
         p.print(5);
         // 调用 print 来打印浮点数
         p.print(500.263);
         // 调用 print 来打印字符串
         p.print("Hello C++");
         Console.ReadKey();
      }
   }
	2). 动态多态性：c#允许你使用关键字abstract创建抽象类，抽象类有一些规则：
你不能创建一个抽象类的实例；你不能在一个抽象类外部申明一个抽象方法；通过在类定义前面放置关键字sealed,可以将类申明为密封类。当一个类被申明为sealed时，它不能被继承。抽象类不能被申明为sealed。
当有一个定义在类中的函数需要在继承类中实现时，可以使用虚方法，虚方法是使用关键字virtual申明的。虚方法可以在不同的继承类中有不同的实现。
动态多态性是通过抽象类和虚方法实现的。

5).接口使用interface关键字申明，他与类的申明类似。接口申明默认是public的。
using System;

interface IMyInterface
{
    // 接口成员
    void MethodToImplement();
}

class InterfaceImplementer : IMyInterface
{
    static void Main()
    {
        InterfaceImplementer iImp = new InterfaceImplementer();
        iImp.MethodToImplement();
    }

    public void MethodToImplement()
    {
        Console.WriteLine("MethodToImplement() called.");
    }
}
InterfaceImplementer 类实现了 IMyInterface 接口，接口的实现与类的继承语法格式类似：
class InterfaceImplementer : IMyInterface
继承接口后，我们需要实现接口的方法 MethodToImplement() , 方法名必须与接口定义的方法名一致。





2.
封装： 提高大家的工作效率。
重构： 先了解重构原则，然后找出可以重构的代码， 明天代码审查就做这个任务。

3.吕梁：http://124.165.225.190:10035 
阳泉：http://124.166.240.220:10035
临汾：http://60.221.207.57:10035

2017-11-9：
1.Echart渲染时报错，说echarts-all.js:1 Dom’s width & height should be ready before init. 但是我是设置了width：100%；height:100%;的，他还是报错了。
解决办法：第一种，宽度高度写死，多少多少px；  第二种，延迟初始化（setTimeout），待jQuery切换完dom宽高ready后再init,
// 初始化
    function init() {
        // 延迟初始化！！！
		setTimeout(function () {
			initFundamentalMapMonitor();
		}, 0);
    }
	init();
	
2.main.js里面有这样一段代码：
Gov.Controls.Pages["home-main"].getDelay = function () {
        return {
            delayFuns: [],
            platformInterval: null,
            time: 10,
            delayExecFun: function (obj) {
                if (obj.delayFuns.length == 0) {
                    clearInterval(obj.platformInterval);
                    obj.platformInterval = null;
                } else {
                    var fun = obj.delayFuns.shift(); // shift()  unshift() 从头部开始操作 shift删除 unshift 添加   push()  pop() 尾部开始操作 push添加  pop 删除
                    fun();
                }
            },
            addDelayFuns: function (fun) {
                this.delayFuns.push(fun);
                if (!this.platformInterval) {
                    this.platformInterval = setInterval(this.delayExecFun, this.time, this);
                }
            }
        }
    }
然后其他地方是这样用的：
		var dataShareDelay = Gov.Controls.Pages["home-main"].getDelay();
		dataShareDelay.addDelayFuns(function () {
            chart.operateVehicleChart.setOption(initOption(dataChart[2])); // 1
        });
        dataShareDelay.addDelayFuns(function () {
            chart.freightVehicleChart.setOption(initOption(dataChart[4])); // 2
        });
        dataShareDelay.addDelayFuns(function () {
            chart.policePlatefromChart.setOption(initOption(dataChart[0])); // 3
        });
        dataShareDelay.addDelayFuns(function () {
            chart.tourismPlatefromChart.setOption(initOption(dataChart[3])); // 4
        });
意思是1,2,3,4这四个方法，每隔10s执行一个，直到执行完毕。即，10s后执行1， 再隔10s执行2，	

2017-11-13：
1. 车辆状态，默认选中：
var status = Gov.Control.Select({
                dbName: "GovStatus",
                selItems: [{ name: "营运", val: 0x2, isSelect: true }, // 默认选中
                           { name: "报废", val: 0x1 },
                           { name: "停运", val: 0x4 },
                           { name: "注销", val: 0x8 },
                           { name: "转出", val: 0x10 },
                           { name: "挂失", val: 0x20 },
                           { name: "歇业", val: 0x40 },
                           { name: "锁定", val: 0x100 },
                           { name: "删除", val: 0x80 }
                ],
                isAllSelect: true,
                isMultiselect: true,
                label: "状态",
                isCondition: true
            });
			
2.云南上次的问题是
Gov-1.1.0.js:
if (opts.detailBtnType) {
   str += '<tr class="detail-btn-line"><td><input class="vehicle-detail-btn vehicle-detail-btn-' + opts.detailBtnType + '" 
   type="button" value=' + opts.btnValue + ' onClick="Gov.showVehicleMoreDetail(' + opts.detailBtnType + ',' + opts.vehicleId + ')" /><td></tr>';
}
最开始的做法是，在Gov-1.1.0.js中，写了showVehicleMoreDetail这个方法，只是方法体是空的，然后onClick绑定的事件是ctl.showVehicleMoreDetail。
然后我去Monitor.js里面写了这个方法ctl.showVehicleMoreDetail， 并在要使用的地方用该方法来重写Gov-1.1.0.js里面的这个showVehicleMoreDetail方法，
后来第一次不点击就自动执行了，然后再去 点击就报错，说找不到ctl.showVehicleMoreDetail。后来跟俊杰兄讨论了知道是ctl在Monitor.js里面的Gov.Page.Query执行完之后就释放掉了，所以报找不到的错误。
所以后来把Monitor.js里面的ctl.showVehicleMoreDetail改成了Gov.showVehicleMoreDetail，这样全局都可以访问了，并且在Gov-1.1.0.js这个里面的onClick事件也可以写成Gov.showVehicleMoreDetail这样了。
最后版本：if (opts.detailBtnType) {
                str += '<tr class="detail-btn-line"><td><input class="vehicle-detail-btn vehicle-detail-btn-' + opts.detailBtnType + '" 
				type="button" value=' + opts.btnValue + ' onClick="Gov.showVehicleMoreDetail(' + opts.detailBtnType + ',' + opts.vehicleId + ')" /><td></tr>';
            }
			
2017-11-14：
1.山西省下面的市：
太原：http://221.180.19.42:10035
忻州：http://211.142.75.30:10035
晋中：202.99.199.61:10035
晋城：124.164.246.52:10035
长治：http://218.26.211.210:10035
大同：121.30.235.186:10035
吕梁：http://124.165.225.190:10035 
阳泉：http://124.166.240.220:10035
临汾：http://60.221.207.57:10035
运城：http://60.222.254.147:10035

内网ip替换：
长治：10.18.8.8:
晋城：10.21.3.8
运城：10.17.7.8

2.四川可重构和完善的地方：
1).地图上面的弹出信息框（包括车辆监管和违章督办，可考虑封装）
2).车辆监管 画历史轨迹 时间选择复制 开始时间的可赋值给下面结束时间 下面的结束时间也可赋值给上面的开始时间
3).车辆监管页面 地图左上角的历史轨迹、车辆跟踪等功能按钮按照是否可以使用来展示（这里有修改了以前的按钮布局模式）
(在做这个的同时，修改和统一了一些布局，也修复了一些显然易见的bug,如点击历史轨迹按钮打开了再点击不能关闭的bug,以及调整了集结按钮的一些样式，使其与其他的按钮样式统一)


2017-11-15：
1.俊杰兄， 四川的我提了两拨代码：
第一波改的【车辆监管 画历史轨迹 时间选择复制 开始时间的可赋值给下面结束时间 下面的结束时间也可赋值给上面的开始时间】， 
第二波改的【车辆监管页面 地图左上角的历史轨迹、车辆跟踪等功能按钮按照是否可以使用来展示】我先提交到这里，你空了在发布吧，这个优先级不高，可以慢慢来，看你咯。
因为改的代码有点多，所以我按一个功能来提交的代码，怕搞混淆了。 
然后明天可能还要做这个【地图上面的弹出信息框（包括车辆监管和违章督办，可考虑封装）这个我看了一下，封装性不是很强，明天我再细细看看】


2017-11-16:
1.长治、晋城、运城内网ip配置替换；
2.山西市考核明细添加竖向滚动条；
3.云南车辆监管车辆详情，返回的table没有的时候，用“---”代替undefined;
4.对象没有length属性，判断一个对象是否为空：
方法一：通过jquery的方法$.isEmptyObj()来判断；
方法二：var a = {};
		if (JSON.stringify(a) == "{}") {
			console.log('空对象');
		}else{
			console.log('非空对象');
		}
		// result: "空对象"
方法三：
		function getObjLength(obj){
			var num = 0;
			for (var attr in obj) {
				num++;
			}
			return num;
		}
		var a = {};
		if (getObjLength(a) > 0) {
			alert('不是空对象');
		}else{
			alert('是空对象');
		}
		
5.山西运城 本地 网约车权限账号:cdgovadmin
		
2017-11-21:
1.	
map.converter = function (obj) {
                function getUnionDate(date, time) {
                    var temp = date + "";
                    var y = parseInt(temp.substr(0, 4)),
                        m = parseInt(temp.substr(4, 2)) - 1,
                        d = parseInt(temp.substr(6, 2));
                    var _date = (+new Date(y, m, d)) + parseInt(time) * 1000;
                    return (new Date(_date)).Format('yyyy-MM-dd hh:mm:ss');
                }
				
				var info = {
                vehicleId: obj.vehicleId,
                plate: obj.plate,
                unitName: obj.unitName,
                platformName: obj.platformName,
                speedLimitSpeed: obj.topSpeed + '/' + obj.speedLimit + ' km/h',
                alarmTypeName: obj.alarmTypeName,
                alarmTime: getUnionDate(obj.sDate, obj.sTime),
                lng: (obj.sLon / 1000000).toFixed(6),
                lat: (obj.sLat / 1000000).toFixed(6),
                direction: 3,
                carType: obj.carType,
                isAlarm: true,
                isSupervise: obj.isSupervise
            };
            var mapping = {
                unitName: "所属企业",
                platformName: "所属接入平台",
                speedLimitSpeed: "速度/限速值",
                alarmTypeName: "报警类型",
                alarmTime: "报警时间"
            }
                
                return {
					info: info,
					mapping: mapping
				}
            };	
			var ret = map.converter(obj);
			var mapLocation = map.mapLocation({
                mapping: ret.mapping,
                info: ret.info,
                title: ret.info.plate,
                ico: {
                    url: Gov.getOrigin() + map.getDirectionImg(ret.info.direction, ret.info.carType, ret.info.isAlarm, ret.info.isSupervise),
                    width: ret.info.isAlarm ? 20 : 12,
                    height: ret.info.isAlarm ? 20 : 12
                }, // marker图标定义
                isInitInfowindow: isInitInfowindow, // 是否初始化infoWindow
                isAjaxData: false, // 是否通过ajax加载数据
                isShift: false, // 是否转化地址
                isSetCenter: isSetCenter, // 是否居中显示
                clearOverLays: isInitInfowindow 
            });
            mapLocation.render();
            index++;
			
			
2017-11-21：
1.封装替换了一些地方，需要测试，特别是历史轨迹上面的marker点击，有按钮“历史轨迹”的， 还需要测试！！！！	



2017-11-23：
1.内蒙和四川的 报表里面双击某一行弹出地图并画轨迹什么的，用到的是/Controls/TabToMap.js, 然后报表用到的有：/Report/VehicleBreakRule.js （validDataDbClick方法）

report_vehiclebreakrule_table_div_tabs0_content_panel0_form0_text2
report_vehiclebreakrule_table_div_tabs0_content_panel0_form0_checkBox0
report_vehiclebreakrule_table_div_tabs0_content_panel1_form0_checkBox0
report_vehiclebreakrule_table_div_tabs0_content_panel2_form0_checkBox0
report_vehiclebreakrule_table_div_tabs0_content_panel3_form0_checkBox0


2017-11-24：
1.
span.fancytree-node.fancytree-active, span.fancytree-node.fancytree-selected {background-color: #172832;}
2.Object.keys() 返回值是一个数组，其中包含对象的可枚举属性和方法的名称。
3.em单位： 相对于当前元素的父级元素的font-size来确定。若： 父级元素：font-size: 16px; 则该子元素中，1em = 16px；这样来换算。

1.湖南区域配置添加地区类型配置组织树


2017-11-27：
1.山西各地市新增服务商问题修改
2.support春雨解决前端问题


2017-11-28:
1.山西市级内网ip配置逻辑修改
2.云南响应式样式调整
3.框架选型对比文档丰富


表格：合计行，动态生成列，模板列，固定前几列

树形：单选，多选，延迟加载

下拉框：自动完成



2017-11-30：
1.svn代码路径： https://222.172.220.248:9888/svn/gov/GovSupervisionPlatform/Trunk/
2.svn检出某个指定文件夹代码（拉指定文件夹代码）： 右键--》版本库浏览器-》选择要检出的目录，然后右键-》检出


2017-12-1：
1.河北新增投诉管理功能；
2.河北统计分析+基本信息样式调整；
3.河北增加配置文件（内外网切换websocket地址用的）；

4.点击空白区域隐藏或关闭div：
假设id="myBox"
$(document).on('click', function(e){
	var e = e || window.event;
	var elem = e.target || e.srcElement;
	while(elem){ // 循环判断至根节点，防止点击的是div的子元素
		if(elem.id && elem.id == "myBox"){
			return;
		}
		elem = elem.parentNode;
	}
	hideDiv(); // 隐藏div的方法
});


2017-12-3：
1.关于input样式的一个问题：
input:-webkit-autofill 导致chrome的输入框背景颜色变成黄色,字体变成黑色 （注意，autocomplete="off" 这个在chrome浏览器中不支持！！！）
如下，chrome默认加的样式：
input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill {
	background-color: rgb(250, 255, 189); /* #FAFFBD; */
	background-image: none;
	color: rgb(0, 0, 0);
}
解决办法：
1). 可以对input:-webkit-autofill使用足够大的纯色内阴影来覆盖input输入框的黄色背景
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill{
  -webkit-box-shadow: 0 0 0 1000px #fff inset !important;
}
如果你有使用圆角等属性，或者发现输入框的长度高度不太对，可以对其进行调整，
除了chrome默认定义的background-color，background-image，color不能用!important
提升其优先级以外，其他的属性均可使用!important提升其优先级，如：
	input:-webkit-autofill {
	-webkit-box-shadow: 0 0 0px 1000px white inset;
	border: 1px solid #CCC!important;
	height: 27px!important;
	line-height: 27px!important;
	border-radius: 0 4px 4px 0;
}


2017-12-4：
1.河北随机抽查配置页面
2.云南查岗bug修复


2017-12-5：
1.伪类和伪元素：
伪类： :active  :focus  :hover  :link  :visited  :first-child  :lang (允许创作者来定义指定的元素中使用的语言)
伪元素： :first-letter  :first-line  :before  :after
两者的区别就是：伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也就是为什么他们一个称为伪类，一个称为伪元素的原因。
伪元素和伪类之所以这么容易混淆，是因为他们的效果类似，而且写法也相仿。但实际上css3为了区分两者，已经明确规定了伪类用一个冒号来表示，伪元素用两个冒号来表示。
CSS3规范中的要求使用双冒号(::)表示伪元素，以此来区分伪元素和伪类，比如::before和::after等伪元素使用双冒号(::)，:hover和:active等伪类使用单冒号(:)。
除了一些低于IE8版本的浏览器外，大部分浏览器都支持伪元素的双冒号(::)表示方法。
然而，除了少部分伪元素，如::backdrop必须使用双冒号，大部分伪元素都支持单冒号和双冒号的写法，比如::after，写成:after也可以正确运行。

2.任务
1.云南“综合监管”修改为“车辆监管”；云南查岗问题发布后测试出另一个bug，完成修复。
2.湖南一车多平台增加日期

3.新拉的项目echart-admin-vue 可部分参考
4.明天来了弄router导航的各个导航的页面内容，如echart, element-ui的table等。


2017-12-6：
1.lodash: 这是一个具有一致接口、模块化、高性能等特性的javascript库。http://lodashjs.com/docs/
2.Moment.js : 是一个javascript日期处理类库。http://momentjs.cn/
3.Element-ui组件库单独引用某个组件的时候，有些可以单独调用他们的一些方法，例如：
import {Notification} from 'element-ui'
Notification.error({
          title: '错误',
          message: '这是一条错误的提示消息'
        });
再举个栗子：
import { MessageBox } from 'element-ui';
MessageBox.confirm('此操作将永久删除该文件, 是否继续?', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning',
          center: true
        }).then(() => {
          this.$message({
            type: 'success',
            message: '删除成功!'
          });
        }).catch(() => {
          this.$message({
            type: 'info',
            message: '已取消删除'
          });
        });
		
4.任务：
1.基于上周未完成的“web框架选型任务”，搭建了一个小型demo，然后按照网约车原型图大致实现了一个首页的布局，然后做了一些关于vue-echarts，table表格, 页面跳转router的试用和测试

各项目远程地址及账号：
查看交通部链路服务器（山西前置机）  
地址：202.97.158.140:12328
帐号：gov_yw
密码：f6f#Ez.P88?U
在该机器上登录（网址：http://10.242.0.110/LMC/stat/city.jsp）查看与交通部链接状态

公司外堡垒机：
地址：182.148.114.194:36589
帐号：temp_yw
密码：Q(e$6mJ73^tN

公司内堡垒机：
地址：125.71.30.131:4999
帐号：zfpt
密码：YHins65(sg2%xn

四川（需登录公司内堡垒机）：
服务器地址：192.168.100.205
帐号：gov05_ser
密码：11HXupD)&1w=

湖南（需登录公司内堡垒机）：
服务器地址：192.168.10.202:4082
帐号：gov_yw
密码：EMm4l8),D,a7

云南（需先登录VPN）：
VPN地址：https://222.221.254.154:4999
VPN帐号：ynwk
VPN密码：ynwk@221133
服务器地址：172.18.217.206
帐号：yun_sjy        
密码：CVsfdfg#87&f4

内蒙堡垒机：
地址：116.113.104.68:23089
帐号：gov_yw
密码：0FV`x&lVr^07

内蒙（需登录内蒙堡垒机）：
服务器地址：192.168.0.131
帐号：gov_yw
密码：C[b[%7K1a7cM

山西省（直接访问）：
地址：202.97.158.140:12327
帐号：gov_yw
密码：2``vI`31EqoF

太原：
地址：221.180.19.42:8010
帐号：gov_yw
密码：#72Xmpr,M[2P

忻州
地址：211.142.75.30:8020
帐号：gov_yw
密码：xpb6,B9Q7<*I

晋中：
地址：202.99.199.61:8020
帐号：gov_yw
密码：5,7e=ZXL_0bz

晋城：
地址：124.164.246.52:8020
帐号：gov_yw
密码：wu4$f3N4F$A#

朔州：
地址：218.26.191.110:8020
帐号：gov_yw
密码：a7#J7[@FSkr9

长治：
地址：218.26.211.210:8020
帐号：gov_yw
密码：@!4q5vGq&9VI

大同：
地址：121.30.235.186:8020
帐号：gov_yw
密码：_gP9p$A7Zi#8

阳泉：
地址：124.166.240.220:8020
帐号：gov_yw
密码：6lnQQ*%~0Kz0

吕梁：
地址：124.165.225.190:8020
帐号：gov_yw
密码：Fm24Q+i1?[Ew

临汾：
地址：60.221.207.57:8020
帐号：gov_yw
密码：~g463)kL*ZKh

运城：
地址：60.222.254.147:8020
帐号：gov_yw
密码：o@b6h!OL&J73



2017-12-7：
1.任务：
1.云南反馈的前端页面问题修改
2.demo左边菜单栏折叠展开功能实现
3.云南车辆监管搜索时组织树第一次没能及时定位问题研究（还未解决）

2017-12-8:
1.任务：
1.内蒙-区县账号屏蔽企业监管页面
2.demo - element-ui树形组件、下拉菜单、弹出框使用

3.现阶段在demo中实现了table合计行，模板列，固定行列，多表头，排序，多选框等。使用router进行页面加载，跳转。
接下来需要：
	1.table实现与分页控件结合，动态生成列。
	2.利用组件技术封装table控件。
	3.对router进行封装简化加载，跳转。
	4.封装form，常用控件。

4.云南组织树定位问题 （玉溪众合运输有限公司）
俊杰兄这样改的：
定义了一个tree里面的全局变量： var scrollToNode = null;
然后添加了：
onExpand: function (node) {
	if (scrollToNode) {
        controlTree.tree("scrollTo", scrollToNode);
        scrollToNode.scrollIntoView(true);
        scrollToNode = null;
    }
}
然后在这里添加了这一句：
function setActiveNode(key) {
    var ctl = treeFindNode(key);
    if (ctl != null) {
        controlTree.tree("select", ctl.target);
        controlTree.tree("expandTo", ctl.target);
        controlTree.tree("scrollTo", ctl.target);
        scrollToNode = ctl.target; // 这句是添加的

        return true;
    }
    return false;
}
俊杰兄说：控件有问题，只有等他展开后再去调用方法了，现在还是有点问题。


2017-12-11：
1.js同步和异步：
同步：程序的执行顺序与任务的排列顺序是一致的、同步的
异步：程序的执行顺序与任务的排列顺序是不一致的、异步的

2.任务：
1.协助湖南移动端部署
2.html标签语义化以及html语义化标签详细了解
3.css框架的一些思考（html标签嵌套，css样式写法，css文件和html文件，html上面添加class选择器或者id选择器）

1.梳理html标签嵌套基本规则
2.css书写规范、顺序，选择器命名规范（区分dom选择器和css的选择器）
3.html文件引用css的方法，css加载顺序问题 （媒体查询顺序）
4.梳理落实到当前项目中应该做哪些修改、调整等
着重介绍：
定位position: absolute  z-index
盒模型box-sizing: border-box;
css sprite:  background-position


2017-12-13:
1.background-color:transparent; 和 opacity: 0;fliter: alpha(opacity=0);的区别
与 background-color: rgba(0,0,0,.4)和 opacity: .4;filter: alpha(opacity=40);的区别都是：
前者只是透明，不会被子元素继承；或者除了透明，还会被子元素继承，例如字体什么的也会跟着透明；

2.云南的cshtml里面写样式的时候加了一个媒体查询，结果就报错了，原因是cshtml语法规定，@在cshtml里面需要转义，如果要输出@，则使用@@。
所以后来的修改方式是重新新建了一个css文件，把css拿出去了。

3.chrome查看元素里面灰色的css属性和被划横线的属性分别代表什么意思：
灰色的css属性：该元素不能继承这个属性（该属性本来就是不可继承的（如background），该元素类别决定其不可继承的（如有些属性不允许外联元素继承，如div是外联元素，其不能继承其父的color属性），差不多就这些）
划横线的属性：注释了这个属性 或者 写错了这个属性或者不支持这个属性（一般浏览器前面会带黄色感叹号）或者 可继承的但是由于优先级问题没有继承被抛弃的。

4.resolution test --- chrome的一个插件，可以修改浏览器窗口的分辨率，从而让网页开发人员能够及时预览页面在不同分辨率下面的表现情况。

5.任务：
1.梳理落实到当前项目中css应该做哪些修改、调整
2.运维巡检
3.修改湖南闭环管理点击报错的问题（cshtml语法规定，@在cshtml里面需要转义，如果要输出@，则使用@@）

6.函数前面加; +  ! ~表示什么意思：
函数前面加;是为了保证压缩的时候不出问题，比如跟上一行代码连接起来或者怎么的。
立即执行函数前面加+（也可以是！或者 ~）,举例说明：
window.Gov = window.Gov == null ? {} : window.Gov;
+function(ns){
	// some code
	ns.config = {};
}(Gov);
如果没有这个加号的话，解析器会认为function是一个函数声明的开始，而后面（）将会导致语法错误。
在function前面加上+号时，就变成了一个函数表达式，而函数表达式后面又添加了一个()就变成了一个立即执行的函数了。
这个立即执行函数等价于下面的代码：
(function(ns){
	// some code
	ns.config = {};
})(Gov);

2017-12-19：
1.湖南sp本地账号： admin 123456
湖南sp线上账号： 997  1C97A1

2.今天任务：
湖南运输企业客户端/省平台需求：
1， 2， 4， 5， 6，省平台需求 （前端的东西修改）


2017-12-21：
1.湖南考核，服务商考核排名报表导出的时候排序字段也要传进去！！！

796过检违章督办数据模拟


2017-12-26：
跳出循环：
1.jquery each ： 跳出当前循环,进入下一个循环（return true; 终止本次循环）； 跳出整个循环（return false;）
2.for循环： 跳出当前循环,进入下一个循环（continue; 终止本次循环）； 跳出整个循环（break;）
3.function里面return，跳出函数。



2017-12-27：
1.云南多地区查岗
2.湖南-凌晨禁行：报表添加车辆的申请时间段；
3.四川-被停业务的服务商所属的车在车辆监管查询时，弹出的提示框时间问题修改；
4.// 判断一个对象是否在一个数组里面
    function findElem(arrayToSearch, attr, val) {
        for (var i = 0; i < arrayToSearch.length; i++) {
            if (arrayToSearch[i][attr] == val) {
                return i;
            }
        }
        return -1;
    }

	
5.四川10.50.75.102 GPS_GOV 数据库

4194312  8388


2017-12-28：
1.四川的库
姚依江—GPS政府 2017/12/27 16:27:49
用201的GPS_GOV_SC
2017/12/27 16:30:42
姚依江—GPS政府 2017/12/27 16:30:42
admin fpI$@wSYnMJ5 可以登录
本地201数据库-四川数据库（GPS_GOV_SC）已经替换为最新存储过程，里面的表数据也基本都有（10月份）

2.云南多地区查岗的需求提交代码的时候，记得先去掉模拟数据！！！

3.
1.云南查岗一些用户体验细节处理，如：查询无数据的提示，地区的初始化等；
2.云南查岗查询接口对接，并配合春雨调试


2017-12-29：
1.云南配合发布
2.了解了一些关于gulp配置文件的书写规则


2018-1-3：
1.四川sp系统本地账号（201数据库）：账号： 510001   密码：123456
2.任务：
	1.四川sp系统-车辆信息修改（车辆信息详情）-车牌颜色添加绿色
	2.协助春雨看了看山西市级的消息通知页面表格数据渲染

3.Virtual Dom算法包括以下几个步骤：
	1.用JavaScript对象结构表示DOM树的结构，然后用这个树构建一个真正的树，插到文档中。
	2.当状态变更的时候，重新构造一个新的对象树。然后用新的树与旧的树进行比较，记录两棵树的差异。
	3.把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。
	
4.《深入react技术栈》看到21页

5.云南闭环管理在线车辆明细，弹出框地图有点问题。什么鬼？？？


2018-1-4：
1.你这边就搬移四川的角色管理
黄俊杰--GPS政府 2018/1/4 14:02:53
还有根据设定的permissionId，js控制权限

2018-1-5：
1.四川角色管理组织树渲染（查询接口还需要后台调整）
2.根据设定的permissioniD,JS控制权限

RoleId: 3, Code: "test1", Name: "test1", State: 1, Comm: "test1"
{"RoleId":10000,"RoleName":"test2","RoleCode":"test2","RoleComm":"","RoleStatus":1}


2018-1-8：
1.任务：
	1.拿到改好的接口，进行调试，完善一些细节的地方。
	2.综合代码调试
	
2018-1-9：
1.跳一跳：https://github.com/faceair/youjumpijump
2.任务：
	1.加了权限控制功能后页面的样式调整，以及第一次登陆进来页面显示方式控制。
	2.web问题讨论
	3.关于春雨的问题：（关于云南项目的一些问题）
		1.云南的基础类库和湖南的有何差异？----- 云南的功能库：websocket等跟四川湖南差不多，然后table，tab，PageLoad，form，map等相关的封装是封装在Gov-1.1.0.js里面的。
		云南项目主要用jquery easyui框架,table,tree等封装也是基于该框架进行封装的，还用到一部分bootstrap的样式，主要是部分按钮和部分form表单在用。
		
		2.各分页面的html是这样嵌入到主页面的？----- 这个主要是Gov-1.1.0.js里面的pageLoad方法在控制。
		页面的最上面的header nav 的属性data-show="comprehensive_manage"控制页面侧边栏body-nav对应的id模块显示；
		侧边栏body-nav里面的每个list-group-item的属性data-id="report_network"，每点击一个就创建一个id属性等于data-id属性的div容器
		（如果是首次加载就创建；如果已经有了，就隐藏同级容器，直接显示当前对应的容器），
		并通过当前点击的list的data-url="/Report/VehicleNetWorkRate"属性来知道要请求什么数据，把请求拿到的数据（这个数据就是我们写的一个一个的分页面）放到刚刚创建的容器里面去，
		然后把该容器追加到#container容器里面去，这样来控制右侧页面的显示隐藏。
		
		3.表格的加载过程，表格的样式是如何渲染的？----- 表格的样式是框架的样式easyui.css自带的，我们所做的就是在easyui的datagrid基础上进行了一下封装，
		还有就是对可以进行排序的列的样式进行了一下处理（可参考Gov-1.1.0.js里面关于table组件封装那一块儿的initSortCloumnStyle方法）
		
	4.自己的问题：
		1.jquery easyui tree? ----- 可查看easyui tree相关的api；对于node节点，可打印出来看
				tree = $("#role_config_tree").tree({
                    animate: true,
                    checkbox: true,
                    data: dataFormat, // tree的文字是通过dataFormat的对象的text属性来渲染的
                    cascadeCheck: true, // 开启联动(父节点勾选子节点全选，父节点取消勾选子节点也全部取消,子节点选完父节点勾选...)
                    onDblClick: function (node) {
                        $("#role_config_menu").html(node.text);
                        setSaveData();
                        rTable.loadQueryTable(node.key, roleId);
                    }
                    
                });
				initTree();
				function initTree() {
					var nodes = $('#role_config_tree').tree('getChildren');
					for (var i in nodes) {
						if (nodes[i].isSelected && nodes[i].children.length == 0) {
							var node = $('#role_config_tree').tree('find', nodes[i].id); // 找到id为role_config_tree这个树的节点id为nodes[i].id的对象
							$('#role_config_tree').tree('check', node.target);//设置选中该节点
						}
					}

					$("#role_config_menu").html("首页分布");

				}
				
		2.jquery判断页面上某个元素是否存在？----- $("#report_online")获取到的永远是对象，不管改元素在页面上是否存在。所以如果要判断，则要使用$("#report_online").length来判断
			例子：if ($("#report_online").length) {console.log("this element is exist");}
			
		3.代码封装基本写法：
			例子：loadPage加载页面封装：
			(function(_){
				_.Loader = _.Loader || {};
				_.Loader.LoadHTML = function(options){
					var ctl = {};
					var opt = {
						container: "container",
						pageClass: "body-content"
					};
					
					Gov.Class.extend(ctl, opt, options); // 把options合并到opt上面去，并添加get set方法，然后合并到ctl上面去
					
					function createId(url, id){
						if (id) {
							return id;
						}
						return url.replace(/\//g, "_").replace(/-/, "").toLowerCase();
					}
					
					function showLoadPage(pageId){
						$(['#', ctl.getPageClass()].join("")).hide();
						$(['#', pageId].join("")).show();
					}
					
					function appendPage(pageId, data){
						var html = '<div id="'+pageId+'" class="'+ctl.getPageClass()+'" name="'+pageId+'">'+data+'</div>';
						$(['#', ctl.getContainer()].join("")).append(html);
					}
					
					function isExistPage(pageId){
						if ($(['#', pageId].join("")).length) { // jquery通过length判断页面上某个元素是否存在
							return true;
						}
						return false;
					}
					
					function loadPage(url, fn){
						Gov.ajax({
							url: url,
							isDialog: true,
							success: function(data){
								fn(data);
							}
						});
					}
					
					function init(url, pageId, fn){
						pageId = createId(url, pageId);
						if (!url) {return;}
						if (isExistPage(pageId)) {
							showLoadPage(pageId);
							return;
						}
						loadPage(url, function(data){
							appendPage(pageId, data);
							showLoadPage(pageId);
							fn && fn();
						});
					}
					
					ctl.loadPage = init;
					
					return ctl;
				}
			})(window.Gov);