<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<input type="text" id="myText" value="input text"/>
<button id="btn1">click me</button>

<ul id="ul1">
    <li>111</li>
    <li>222</li>
    <li>333</li>
</ul>

<!--42.经典的css垂直居中方法-->
<div style="position: relative;background-color:green;width:500px;height:300px;">
    <div style="width:50%;height:50%;margin: auto;position:absolute;
    left:0;top:0;bottom:0;right:0;background-color:greenyellow;">
        兼容性：所有现代浏览器&ie8&ie8+
    </div>
</div>

<script>
    //正则表达式复习
    // 1).过滤出一个字符串中的数字
    var string1 = '#@1.309$';
    //把所有不是数字不是.也不是$的字符替换成空字符串
    //i : ignore  g: global
    var str1 = string1.replace(/[^\d,^{.},^{$}]/ig, '');
    console.log(str1); // 1.309$
    //把所有数字和.替换成字母t
    var str1_2 = string1.replace(/[\d,{.}]/ig,'t');
    console.log(str1_2); //#@ttttt$

    //2).找到第一个出现数字的位置
    var string2 = 'fdjk@1.23efj';
    console.log(string2.search(/\d/)); // 5

    //3).三个数字连着的
    var string3 = 'tyd35h345fsa';
    var str3 = string3.match(/\d\d\d/g);
    console.log(str3); //["345"]

    //4).若干个数字
    var string4 = 'hs5624mf734f32f5dd0';
    var str4 = string4.match(/\d+/g);
    console.log(str4); // ["5624", "734", "32", "5", "0"]

    //5).除了大写字母和数字以外的
    var string5 = '#jTyhT$T78s0s';
    var str5 = string5.replace(/[^\d,^A-Z]/g,'Q');
    console.log(str5); // QQTQQTQT78Q0Q

    //6).除了小写字母和数字以外的
    var string6 = '#jTyhT$T78s0s';
    var str6 = string6.replace(/[^a-z,^\d]/g,'H');
    console.log(str6); // HjHyhHHH78s0s


    //闭包复习
    //闭包只能取得包含函数中任何变量的最后一个值
    function test1(){
        var result = [];
        for(var i=0; i<10; i++){
            result[i] = function(){
                alert(i);
            };
        }
        return result;
    }
    console.log(test1());
    //test1()[1](); // 10



    /*变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实
     都是一个新的变量，所以最后输出的是 1*/
    function test3(){
        var result = [];
        for(let i=0; i<10; i++){
            result[i] = function(){
                alert(i);
            };
        }
        return result;
    }
    //test3()[1](); // 弹出 1



    //我们可以通过创建另一个匿名函数强制让闭包的行为符合预期
    function test2(){
        var result = [];
        for(var i=0; i<10; i++){
            result[i] = function(num){
                return function(){
                    alert(num);
                }
            }(i);
            //也可以这样写
            /*(function(m){
                result[m] = function(){
                    alert(m);
                };
            })(i);*/
        }
        return result;
    }
    for(var i=0; i<test2().length; i++){
        //test2()[i](); // 0,1,2,3,...,8,9
    }


    /*什么是闭包？举例说明*/

    //在函数外部自然无法读取函数内的局部变量。
    /*function f1(){
     var n=999;
     }
     alert(n); // error*/

    //出于种种原因，我们有时候需要得到函数内的局部变量。
    // 但是，前面已经说过了，正常情况下，这是办不到的，只
    // 有通过变通方法才能实现。
    //那就是在函数的内部，再定义一个函数。

    //闭包可以用在许多地方。它的最大用处有两个，
    // 一个是前面提到的可以读取函数内部的变量，
    // 另一个就是让这些变量的值始终保持在内存中。（不会被回收机制所回收）

    function f1() {
        var n = 999;
        nAdd = function () {
            n += 1
        }; //全局变量
        function f2() {
            alert(n);
        }

        return f2;
    }
    /*var result = f1();
    result(); // 999
    nAdd();
    result(); // 1000*/


    //闭包中关于this对象
    //在全局函数中，this 等于window，而当函数被作为某个对象的方法调用时，this 等
    //于那个对象。不过，匿名函数的执行环境具有全局性，因此其this 对象通常指向window
    var name = "The Window";
    var object = {
        name : "My Object",
        getNameFunc : function(){
            return function(){
                return this.name;
            };
        }
    };
    console.log(object.getNameFunc()()); // The Window 【匿名函数的执行环境具有全局性,this指向window】


    var name = "The Window";
    var object = {
        name : "My Object",
        getNameFunc : function(){
            var that = this;
            return function(){
                return that.name;
            };
        }
    };
    console.log(object.getNameFunc()()); // My Object









    //判断一个字符串中字符出现次数最多的字符
    var s = 'acadaddaacamtyjbhfa';
    var json = {};
    for(var i=0; i< s.length; i++){
        if(!json[s.charAt(i)]){
            json[s.charAt(i)] = 1;
        }else{
            json[s.charAt(i)]++;
        }
    }
    var iMax = 0;
    var ss = '';
    for(var i in json){
        if(json[i] > iMax){
            iMax = json[i];
            ss = i;
        }
    }
    console.log('出现次数最多的字符是：'+ss+',次数是'+iMax);


    //获取json对象的长度
    //json对象没有length
    var json1 = {"name":"jessie","sex":"female","age":"23"};
    function getJsonLength(json){
        var jsonLength = 0;
        for(var i in json){
            jsonLength++;
        }
        return jsonLength;
    }
    console.log(getJsonLength(json1)); // 3



    //call apply的用法意义以及区别
    //两者的作用都是：改变对象的this指向的内容
    //写法不同：
    // fun.call(func1,var1,var2,var3);
    // func.apply(func1,[var1,var2,var3]);
    //使用apply的好处是可以将当前函数的arguments对象作为apply的第二个参数传入
    function obj(){
        this.value = '对象';
    }
    var value = 'global对象';
    function fun1(){
        console.log(this.value);
    }
    window.fun1(); //global对象
    fun1.call(window); // global对象
    fun1.call(document.getElementById('myText')); // input text
    fun1.call(new obj()); //对象



    //数组去重
    function unique(arr){
        var isRepeated, result = [];
        for(var i=0; i<arr.length; i++){
            isRepeated = false;
            for(var j=0; j<result.length; j++){
                if(arr[i] === result[j]){
                    isRepeated = true;
                    break;
                }
            }
            if(!isRepeated){
                result.push(arr[i]);
            }
        }
        return result;
    }
    var arr = [1,2,3,4,3,2,1,2,3];
    console.log(unique(arr)); // [1, 2, 3, 4]

    //es6中有提出一种去重的方法
    //ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是【唯一】的，没有重复的值。
    var repeatArr = [1,2,3,4,3,2,1,2,3];
    function uniqueSet(arr){
        return [...new Set(arr)]; // 返回的是set数组结构
    }
    console.log(uniqueSet(repeatArr)); // [1, 2, 3, 4]
    //Array.from方法可以将Set结果转为数组
    var set = new Set([1,2,3,2,1]);
    console.log(Array.from(set)); //[1, 2, 3]
    //这就提供了数组去除重复成员的另一种方法
    function unique2(arr){
        return Array.from(new Set(arr));
    }
    console.log(unique2(arr)); // [1, 2, 3, 4]



    //变量提升，函数声明提升
    /*alert(x);
    var x = "111";
    alert(x);
    x="222";
    function x(){return x;}
    alert(x);*/
    /*
      var x;
      function x(){return x;}
      alert(x);
      x = "111";
      alert(x);
      x = "222";
      alert(x);
    */
    //输出结果：
    /*
    function x(){return x;}
    111
    222
    **/

    /*function Foo() {
        getName = function () { alert (1); };
        return this;
    }
    Foo.getName = function () { alert (2);};
    Foo.prototype.getName = function () { alert (3);};
    var getName = function () { alert (4);};
    function getName() { alert (5);}*/

    /*等价于
     var getName; //变量提升
     function getName(){alert(5);} //函数声明提升
     function Foo() {
     getName = function () { alert (1); };
     return this;
     }
     Foo.getName = function () { alert (2);};
     Foo.prototype.getName = function () { alert (3);};
     getName = function () { alert (4);};
    */

    //问题
    /*Foo.getName();  // 2
    getName();  // 4
    Foo().getName();  // 1
    getName(); // 1
    new Foo.getName(); // 2
    new Foo().getName();  // 3
    new new Foo().getName();  // 3
*/


    //写出运行结果
    var arrTest=['1',2,false,true];
    arrTest[5]=function(){alert('a');};
    //alert(arrTest); // ['1',2,false,true,,function(){alert('a');};]
    //alert(arrTest.length); // 6



    // 深度克隆---js对象引用
    /*var a = [1,2,3];
    var b = a; // a b共用一个引用
    b.push(4);
    alert(b); // [1,2,3,4]
    alert(a); // [1,2,3,4]
    */

    /*var a = [1,2,3];
    var b = a;
    b = [1,2,3,4]; // b新开了一个引用
    alert(b); // [1,2,3,4]
    alert(a); // [1,2,3]
*/

    /*var obj = {
        a: 10
    };
    var obj2 = obj;
    obj2.a = 20;
    alert(obj.a); // 20
*/

    /*var obj = {
        a: 10
    };
    function copy(obj){ // 浅拷贝, 只拷贝的一层
        var newObj = {};
        for(var attr in obj){
            newObj[attr] = obj[attr];
        }
        return newObj;
    }
    var obj2 = copy(obj);
    obj2.a = 20;
    alert(obj.a); // 10
*/

    /*var obj = {
        a: {
            b: 10
        }
    }
    function copy(obj){  //浅拷贝， 只拷贝了一层
        var newObj = {};
        for(var attr in obj){
            newObj[attr] = obj[attr];
        }
        return newObj;
    }
    var obj2 = copy(obj);
    obj2.a.b = 20;
    alert(obj.a.b); // 20
    */


    //求nX(n-1)X(n-2)X...X2X1
    // 递归：（1）函数调用函数自身，执行递的动作
    //      （2）最后一次判断一个终止条件，可以执行归的动作
     /*function test(n){
         if(n == 1){
            return 1;
         }
        return n*test(n-1);
     }
     alert(test(5)); // 120
    */

    // arguments的应用
    /*function factorial(n){
          if (n <= 0){
              return 1;
          } else{
              return n * arguments.callee(n-1);
          }
    }
    alert(factorial(5)); // 120*/


    //深拷贝
    /*function deepClone(obj){
        var newObj = {};
        if(typeof obj != 'object'){ // 指定递归结束的条件
            return obj;
        }
        for(var attr in obj){
            newObj[attr] = deepClone(obj[attr]);
        }
        return newObj;
    }
    var obj = {
        a: {
            b: 10
        }
    };
    var obj2 = deepClone(obj);
    obj2.a.b = 20;
    alert(obj.a.b); // 10
*/
    function deepClone(obj){
        var newObj = {};
        if(typeof obj != 'object'){
            return obj;
        }
        for(var attr in obj){
            newObj[attr] = deepClone(obj[attr]);
        }
        return newObj;
    }

    //arguments的应用
    /*Javascrip中国每个函数都会有一个Arguments对象实例arguments，
    它引用着函数的实参，可以用数组下标的方式"[]"引用arguments的元素。
    arguments.length为函数实参个数，arguments.callee引用函数自身*/
    //1)求给定的若干个值中的最大值
    function max(a,b){
        return a-b>0 ? a : b;
    }
    function Max(){
        var maxValue = arguments[0];
        for(var i=1; i<arguments.length; i++){
            if(maxValue < arguments[i]){
                maxValue = arguments[i];
            }
        }
        return maxValue;
    }
    console.log(Max(1,2,0,-10,100,5)); // 100
    /*我们知道每一个对象都有自己的属性，arguments对象也不例外，首先arguments的访问犹如Array对象一样，
     用0到arguments.length-1来枚举每一个元素。下面我们来看看callee属性，返回正被执行的 Function 对象，
     也就是所指定的 Function 对象的正文。callee 属性是 arguments 对象的一个成员，仅当相关函数正在执行时才可用。
     callee 属性的初始值就是正被执行的 Function 对象，这允许匿名的递归函数。
     需要注意的是：
     1.arguments是一个object对象，它不是数组，不能对它使用shift、push、join等方法。
     2.上述举例时用的arguments[i]中的i只是作为arguments对象的属性，并不能理解为数组下标。

     3.命名参数只提供便利，不是必须的；如果没有声明，可以用arguments[i]来访问数据。
     4.没有传递值的命名参数将自动赋予undefined。*/
    //2)arguments.callee
    function factorial(n){
        if (n <= 0){
            return 1;
        } else{
            return n * arguments.callee(n-1);
        }
    }
    console.log(factorial(5)); // 120



    //判断一个对象是否具有某个属性
    //对象的写法
    var myObj = {
        "width": 1,
        "height": 2
    };
    if(myObj["width"]){
        console.log(myObj["width"]); // 1
    }
    if(myObj.height){
        console.log(myObj.height); // 2
    }
    //判断js对象是否拥有某属性
    //1).in运算符
    console.log("width" in myObj); // true
    console.log("toString" in myObj); // true
    //可看到无论是name，还是原形链上的toString，都能检测到返回true。

    //2).hasProperty方法
    console.log(myObj.hasOwnProperty("width")); // true
    console.log(myObj.hasOwnProperty("toString")); // false
    //原型链上继承过来的属性无法通过hasOwnProperty检测到，返回false。

    Object.prototype.say = "hello"; // 添加到对象Object上面
    for(var i in myObj){
        console.log(myObj[i]); // 1 2 hello
    }

    var test = [1,2,3,4];
    Array.prototype.say = "hello"; //添加到数组Array上面
    for(var i in test){
        console.log(test[i]); // 1  2  3  4  hello
    }

    //改进：
    Object.prototype.say = "hello"; // 添加到对象Object上面
    for(var i in myObj){
        if(myObj.hasOwnProperty(i)){
            console.log(myObj[i]); // 1 2
        }
    }

    var test = [1,2,3,4];
    Array.prototype.say = "hello"; //添加到数组Array上面
    for(var i in test){
        if(test.hasOwnProperty(i)){
            console.log(test[i]); // 1  2  3  4
        }
    }

    //Set的写法
    var set = new Set();
    set.add("width");
    set.add("height");
    if(set.has("width")){
        console.log(set); // Set {"width", "height"}
        console.log([...set]); // ["width", "height"]
    }



    //js dom操作获取节点的一些常用的方法
    //js获取下一个兄弟节点
    function getNextSibling(eleObj){
        var next = eleObj.nextSibling;
        if(next.nodeType == 3){ // 文本节点
            return next.nextSibling;
        }
        return next;
    }
    //js获取上一个兄弟节点
    function getPreviousSibling(eleObj){
        var pre = eleObj.previousSibling;
        if(pre.nodeType == 3){
            return pre.previousSibling;
        }
        return pre;
    }
    //js获取所有子节点
    function getChildNodes(parentNode){
        var childs = [];
        for(var i=0; i<parentNode.childNodes.length; i++){
            if(parentNode.childNodes[i].nodeType == 1){ // 元素节点
                childs.push(parentNode.childNodes[i]);
            }
        }
        return childs;
    }

    //js获取第一个子节点
    function getFirstChildNode(parentNode){
        var first = parentNode.firstChild;
        if(first.nodeType == 3){ // 文本节点
            return first.nextSibling;
        }
        return first;
        /*return parentNode.firstElementChild;*/
    }
    //js获取最后一个子节点
    function getLastChildNode(parentNode){
        var last = parentNode.lastChild;
        if(last.nodeType == 3){
            return last.nextSibling;
        }
        return last;
    }



    //创建一个函数，用以解析查询字符串，然后返回包含所有参数的一个对象
    // window.location.search ==> "?q=javascript" ==>返回URL的查询字符串。这个字符串以问号开头
    function getQueryStringArgs(url){
        url = url == null ? window.location.href : url;
        var qs = url.substring(url.lastIndexOf("?") + 1);
        // var qs = (window.location.search.length > 0 ? window.location.search.substring(1) : search);
        var args = {};
        var items = qs.length > 0 ? qs.split('&') : [];
        var item = null;
        var name = null;
        var value = null;
        for(var i=0; i<items.length; i++){
            item = items[i].split("=");
            //用decodeURIComponent()分别解码name 和value（因为查询字符串应该是被编码过的）。
            name = decodeURIComponent(item[0]);
            value = decodeURIComponent(item[1]);

            if(name.length){
                args[name] = value;
            }
        }

        return args;
    }
    console.log(getQueryStringArgs('https://www.baidu.com/baidu?tn=monline_3_dg&ie=utf-8&wd=12306%E7%81%AB%E8%BD%A6%E7%A5%A8%E7%BD%91%E4%B8%8A%E8%AE%A2%E7%A5%A8%E5%AE%98%E7%BD%91'));
    // Object {tn: "monline_3_dg", ie: "utf-8", wd: "12306火车票网上订票官网"}
    function getUrlObj(url){
        url = url == null ? window.location.href : url;
        var search = uel.substring(url.lastIndexOf('?')+1);
        var obj = {};
        var items = search.length > 0 ? search.split('&') : [];
        var item = null;
        var name = null;
        var value = null;
        for(var i=0; i<items.length; i++){
            item = items[i].split('=');
            name = decodeURIComponent(item[0]);
            value = decodeURIComponent(item[1]);

            if(name.length){
                obj[name] = value;
            }
        }
        return obj;
    }

    // 将url的查询参数解析成字典对象
    function getQueryObject(url) {
        url = url == null ? window.location.href : url;
        var search = url.substring(url.lastIndexOf("?") + 1);
        var obj = {};
        var reg = /([^?&=]+)=([^?&=]*)/g;
        // [^?&=]+表示：除了？、&、=之外的一到多个字符
        // [^?&=]*表示：除了？、&、=之外的0到多个字符（任意多个）
        search.replace(reg, function (rs, $1, $2) {
            var name = decodeURIComponent($1);
            var val = decodeURIComponent($2);
            val = String(val);
            obj[name] = val;
            return rs;
        });
        return obj;
    }
    console.log(getQueryObject('https://www.baidu.com/baidu?tn=monline_3_dg&ie=utf-8&wd=12306%E7%81%AB%E8%BD%A6%E7%A5%A8%E7%BD%91%E4%B8%8A%E8%AE%A2%E7%A5%A8%E5%AE%98%E7%BD%91'));
    // Object {tn: "monline_3_dg", ie: "utf-8", wd: "12306火车票网上订票官网"}


    function getQueryObject2(url){
        url = url = null ? window.location.herf : url;
        var qs = url.substring(url.lastIndexOf('?') + 1);
        var obj = {};
        var items = qs.length > 0 ? qs.split('&') : [];
        var item = null;
        var name = null;
        var value = null;
        for(var i=0; i<items.length; i++){
            item = items[i].split('=');
            name = decodeURIComponent(item[0]);
            value = decodeURIComponent(item[1]);
            if(name.length){
                obj[name] = value;
            }
        }
        return obj;
    }
    console.log(getQueryObject2('http://www.cuit.edu.cn?name=jessie&pass=123'));
    // Object {name: "jessie", pass: "123"}


    function getQueryObject3(url){
        url = url = null ? window.location.href : url;
        var qs = url.substring(url.lastIndexOf('?') + 1);
        var obj = {};
        var reg = /([^?&=]+)=([^?&=]*)/g;
        qs.replace(reg, function(rs, $1, $2){
            var name = decodeURIComponent($1);
            var val = decodeURIComponent($2);
            val = String(val);
            obj[name] = val;
            return rs;
        });
        return obj;
    }
    console.log(getQueryObject3('http://www.cuit.edu.cn?name=jessie&pass=123'));
    // Object {name: "jessie", pass: "123"}



    // 描述一下js里面的事件的三个阶段
    /*
     DOM2级事件模型中规定了事件流的三个阶段：捕获阶段、目标阶段、冒泡阶段。低版本ie（ie8及其以下不支持捕获阶段）
     捕获事件流：Netscape提出的事件流，即事件由页面元素接收，逐级向下，传播到最具体的元素。
     冒泡事件流：IE提出的事件流，即事件由最具体的元素接收，逐级向上，传播到页面元素。
     */



    // IE和W3C不同绑定事件解绑事件的方法有什么区别，参数分别是什么，以及事件对象e有什么区别?

    // w3c  target.addEventListener(event,listener,capture);
    /* event-->事件名，不带'on'
    listener-->事件触发时执行的函数
    useCapture-->指定事件是否在捕获阶段或者冒泡阶段执行，
    为true时事件句柄在捕获阶段执行，为false时事件句柄在冒泡阶段执行。
    */
    // w3c target.removeEventListener(event,function, capture/bubble);


    // ie  target.attachEvent(type, listener);
    /* type: 事件名， 带on, for example: onclick, onkeyup onmouseover and so on.
    listener-->实现了EventListener接口或者是javascript中的函数。*/
    // ie target.detachEvent(event, function);

    // 封装成js函数
    function myAddEvent(obj, ev, fn){
        if(obj.attachEvent){ // ie
            obj.attachEvent('on'+ev, fn);
        }else{
            obj.addEventListener(ev, fn, false);
        }
    }

    myAddEvent(document.getElementById('btn1'), 'click', function(){
        alert(this.innerHTML);
    });





    //事件的委托（代理 Delegated Events）的原理以及优缺点
    //事件委托原理：事件冒泡机制
    // 优点：1.可以大量节省内存占用，减少事件注册。比如table上代理所有td的click事件就很不错
    // 2.可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为合适
    // 缺点：事件代理的常用应用应该仅限于上述需求，如果把所有事件都用事件代理，可能会出现事件误判。
    // 即本不该被触发的事件被绑定上了事件
    var oUl1 = document.getElementById('ul1');
    myAddEvent(oUl1,'click',function(e){
        var e = e || window.event;
        var target = e.target || e.srcElement;
        if(target.nodeName === 'LI'){
            alert(target.innerHTML);
            target.style.background = 'red';
        }
    });



    //前端性能优化
    /*
        1)js异步加载[参考：http://blog.csdn.net/l522703297/article/details/50754695]
        【 对于支持HTML5的浏览器，实现JS的异步加载只需要在script元素中加上async属性，
        为了兼容老版本的IE还需加上defer属性；对于不支持HTML5的浏览器(IE可以用defer实现)，可以采
        用以上几种方法实现。原理基本上都是向DOM中写入script或者通过eval函数执行JS代码，你可以把
        它放在匿名函数中执行，也可以在onload中执行，也可以通过XHR注入实现，也可以创建一个iframe
        元素，然后在iframe中执行插入JS代码。 】
        2)css js打包压缩后上传到服务器
        3)用npm bower等工具进行项目依赖管理
        4)img lazy Loading
        5)使用css sprites技术，加速图片的显示，减少http请求数量
    */




    //闭包原理及其应用
    /*什么情况下会发生闭包，为什么需要闭包，什么场景下需要，闭包闭了谁，怎么释放被闭包的
     变量内存，闭包的优点是什么，缺点是什么等等。*/
    function fun(n,o) {
        console.log(o);
        return {
            fun:function(m){
                return fun(m,n);
            }
        };
    }
    var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,0,0,0
    var b = fun(0).fun(1).fun(2).fun(3);//undefined,0,1,2
    var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,0,1,1

    //问:三行a,b,c的输出分别是什么？

    /*函数作用域链的问题*/
    /*测试1，对象内部的函数表达式*/
    var o={
        fn:function (){
            console.log(fn);
        }
    };
    //o.fn();//ERROR报错: fn is not defined(…)

    /*测试2，非对象内部的函数表达式*/
    var fn = function(){
        console.log(fn);
    };
    fn(); //function(){console.log(fn);}

    /*结论是：使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；在对象内部的不能访问到。
     原因也非常简单，因为函数作用域链的问题，采用var的是在外部创建了一个fn变量，
     函数内部当然可以在内部寻找不到fn后向上册作用域查找fn，而在创建对象内部时，
     因为没有在函数作用域内创建fn，所以无法访问。

     所以综上所述，可以得知，最内层的return出去的fun函数不是第二层fun函数，是最外层的fun函数。

     所以，三个fun函数的关系也理清楚了，第一个等于第三个，他们都不等于第二个。*/
    /* var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,0,0,0
     可以得知，第一个fun(0)是在调用第一层fun函数。第二个fun(1)是在调用前一个fun的返回值的fun函数，所以：

     第后面几个fun(1),fun(2),fun(3),函数都是在调用第二层fun函数。
     遂：

     在第一次调用fun(0)时，o为undefined；

     第二次调用fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，
     并在内部调用第一层fun函数fun(1,0);所以o为0；

     第三次调用fun(2)时m为2，但依然是调用a.fun，所以还是闭包了第一次调用时的n，
     所以内部调用第一层的fun(2,0);所以o为0

     第四次同理；*/
    /*var b = fun(0).fun(1).fun(2).fun(3);//undefined,0,1,2
     先从fun(0)开始看，肯定是调用的第一层fun函数；而他的返回值是一个对象，所以第二个fun(1)调用的是第二层fun函数，
     后面几个也是调用的第二层fun函数。

     遂：

     在第一次调用第一层fun(0)时，o为undefined；

     第二次调用 .fun(1)时m为1，此时fun闭包了外层函数的n，也就是第一次调用的n=0，即m=1，n=0，
     并在内部调用第一层fun函数fun(1,0);所以o为0；

     第三次调用 .fun(2)时m为2，此时当前的fun函数不是第一次执行的返回对象，而是第二次执行的返回对象。
     而在第二次执行第一层fun函数时时(1,0)所以n=1,o=0,返回时闭包了第二次的n，遂在第三次调用第三层fun
     函数时m=2,n=1，即调用第一层fun函数fun(2,1)，所以o为1；

     第四次调用 .fun(3)时m为3，闭包了第三次调用的n，同理，最终调用第一层fun函数为fun(3,2)；所以o为2；
     */



    // 手写数组快速去重、快速排序方法
    function quickUnique(arr){
        return Array.from(new Set(arr));
    }
    function quickUnique2(arr){
        var result = [];
        var isRepeated;
        for(var i=0; i<arr.length; i++){
            isRepeated = false;
            for(var j=0; j<result.length; j++){
                if(arr[i] === result[j]){
                    isRepeated = true;
                }
            }
            if(!isRepeated){
                result.push(arr[i]);
            }
        }
        return result;
    }
    var arr = [1,2,3,2,1];
    console.log(quickUnique(arr)); // [1,2,3]
    console.log(quickUnique2(arr)); // [1,2,3]

    function quickSort(arr){ // 从大到小
        if(arr.length <= 1){ //这个必须要，不然报堆栈溢出的错误---指定递归结束的条件
            return arr;
        }
        var left = [],
                right = [],
                middle = [];
        var middleValue = arr[Math.floor(arr.length / 2)];
        for(var i=0; i<arr.length; i++){
            if(arr[i] > middleValue){
                left.push(arr[i]);
            }else if(arr[i] < middleValue){
                right.push(arr[i]);
            }else{
                middle = arr[i];
            }
        }
        return [].concat(quickSort(left),middle,quickSort(right));
    }
    var arr1 = [1, -100, 2000, 0, 1];
    console.log(quickSort(arr1)); // [2000, 1, 0, -100]

    //冒泡排序
    function bubbleSort(arr){ // 从小到大
        var temp;
        for(var i=0; i<arr.length; i++){
            for(var j=0; j<arr.length; j++){
                if(arr[j] > arr[j+1]){
                    temp = arr[j+1];
                    arr[j+1] = arr[j];
                    arr[j] = temp;
                }
            }
        }
        return arr;
    }
    console.log(bubbleSort(arr1)); // [-100, 0, 1, 1, 2000]


    /*=== javascript经典面试 ===*/

    /*1、使用 typeof bar === "object" 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？*/
    var obj = {};
    var arr = [];
    console.log(typeof obj === 'object'); //true
    console.log(typeof arr === 'object'); //true
    console.log(typeof null === 'object'); //true
    /*从上面的输出结果可知，typeof bar === "object" 并不能准确判断 bar 就是一个 Object。
     可以通过 Object.prototype.toString.call(bar) === "[object Object]" 来避免这种弊端：*/
    console.log(Object.prototype.toString.call(obj)); //[object Object]
    console.log(Object.prototype.toString.call(arr)); //[object Array]
    console.log(Object.prototype.toString.call(null)); //[object Null]



    /*2、下面的代码会在 console 输出神马？为什么？*/
    (function(){
        var a = b = 3;
    })();
    /*console.log("a defined? " + (typeof a !== 'undefined'));
     console.log("b defined? " + (typeof b !== 'undefined'));*/
    //console.log(a); // a is not defined
    console.log(b); // 3
    /*拆解一下自执行函数中的变量赋值：
     b = 3;
     var a = b;
     所以 b 成了全局变量，而 a 是自执行函数的一个局部变量。*/


    /*3、下面的代码会在 console 输出神马？为什么？*/
    var myObject = {
        foo: "bar",
        func: function() {
            var self = this;
            console.log("outer func:  this.foo = " + this.foo);
            console.log("outer func:  self.foo = " + self.foo);
            (function() {
                console.log("inner func:  this.foo = " + this.foo);
                console.log("inner func:  self.foo = " + self.foo);
            }());

            //用闭包来解决
            (function(test){
                console.log(test.foo);
                console.log(self.foo);
            })(self);
        }
    };
    myObject.func();
    /*
     * 输出结果：
     outer func:  this.foo = bar
     outer func:  self.foo = bar
     inner func:  this.foo = undefined
     inner func:  self.foo = bar
     * */
    /* //在全局函数中，this 等于window，而当函数被作为某个对象的方法调用时，this 等
     //于那个对象。不过，匿名函数的执行环境具有全局性，因此其this 对象通常指向window*/
    /*用闭包解决：
     (function(test) {
     console.log("inner func:  this.foo = " + test.foo);  //'bar'
     console.log("inner func:  self.foo = " + self.foo);
     }(self));
     * */



    /*4、将 JavaScript 代码包含在一个函数块中有神马意思呢？为什么要这么做？
     * 换句话说，为什么要用立即执行函数表达式（Immediately-Invoked Function Expression）。
     IIFE 有两个比较经典的使用场景，一是类似于在循环中定时输出数据项，
     二是类似于 JQuery/Node 的插件和模块开发。
     * */
    /*for(var i = 0; i < 5; i++) {
     setTimeout(function() {
     console.log(i);
     }, 1000);
     }*/
    /*上面的输出并不是你以为的0，1，2，3，4，而输出的全部是5，这时 IIFE 就能有用了：*/
    /*for(var i = 0; i < 5; i++) {
     (function(m){
     setTimeout(function() {
     console.log(m);
     }, 1000);
     })(i);
     }*/
    /* 输出 0，1，2，3，4 */
    /*而在 JQuery/Node 的插件和模块开发中，为避免变量污染，也是一个大大的 IIFE：*/
    /*(function($){
//代码
    })(jQuery);*/
    for(var i=0; i<5; i++){
        setTimeout(function(){
            console.log(i);
        }, 1000);
    }

    // 改成立即执行函数
    for(var i=0; i<5; i++){
        (function(m){
            setTimeout(function(){
                console.log(m);
            }, 1000);
        })(i);
    }

    //同样的例子
    function test3(){
        var result = [];
        for(var i=0; i<10; i++){
            result[i] = function(num){
                return function(){
                    alert(num);
                }
            }(i);
            //也可以这样写
            /*(function(m){
             result[m] = function(){
             alert(m);
             };
             })(i);*/
        }
        return result;
    }




    /* 5、在严格模式('use strict')下进行 JavaScript 开发有神马好处？*/

    /*1)消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;

     2)消除代码运行的一些不安全之处，保证代码运行的安全；

     3)提高编译器效率，增加运行速度；

     4)为未来新版本的Javascript做好铺垫。*/






    /*6、下面两个函数的返回值是一样的吗？为什么？*/
    function foo1()
    {
        return {
            bar: "hello"
        };
    }

    function foo2()
    {
        return
        {
            bar: "hello"
        };
    }
    console.log(foo1()); // Object {bar: "hello"}
    console.log(foo2()); // undefined
    /*
     * 在编程语言中，基本都是使用分号（;）将语句分隔开，这可以增加代码的可读性和整洁性。
     * 而在JS中，如若语句各占独立一行，通常可以省略语句间的分号（;），JS 解析器会根据能
     * 否正常编译来决定是否自动填充分号：
     var test = 1 +
     2
     console.log(test);  //3
     在上述情况下，为了正确解析代码，就不会自动填充分号了，但是对于 return 、break、continue 等语句，
     如果后面紧跟换行，解析器一定会自动在后面填充分号(;)，所以上面的第二个函数就变成了这样：
     function foo2()
     {
     return;
     {
     bar: "hello"
     };
     }
     所以第二个函数是返回 undefined。
     * */






    /*7、神马是 NaN，它的类型是神马？怎么测试一个值是否等于 NaN?*/
    /*NaN 是 Not a Number 的缩写，JavaScript 的一种特殊数值，
     其类型是 Number，!!!
     可以通过 isNaN(param) 来判断一个值是否是 NaN：*/
    console.log(isNaN(NaN)); //true

    console.log(isNaN(23)); //false

    console.log(isNaN('ds')); //true

    console.log(isNaN('32131sdasd')); //true

    console.log(NaN === NaN); //false !!!

    console.log(NaN === undefined); //false

    console.log(undefined === undefined); //true !!!

    console.log(typeof NaN); //number !!!

    console.log(Object.prototype.toString.call(NaN)); //[object Number]

    //alert(NaN+1);  // NaN
    /*javascript:alert(NaN+1);结果是无穷大.
     但唯一的是NaN是一个不确定数,所以NaN不能等于NaN.
     这好比是randomise中的random,random +1 还是一个不确定的数值,但random不会等于
     random一样.两者的区别在于random能生成一个确定数,但本身不确定.而NaN生成的就是
     一个不确定数.*/




    /*8、解释一下下面代码的输出*/
    console.log(0.1 + 0.2);   //0.30000000000000004
    console.log(0.1 + 0.2 == 0.3);  //false
    // 【二进制浮点数表示法并不能精确的表示类似0.1这样 的简单的数字，会有舍入误差】
    /*
     * JavaScript 中的 number 类型就是浮点型，JavaScript 中的浮点数采用IEEE-754 格式的规定，这是一种二进制表示法，可以精确地表示分数，比如1/2，1/8，1/1024，每个浮点数占64位。但是，二进制浮点数表示法并不能精确的表示类似0.1这样 的简单的数字，会有舍入误差。


     由于采用二进制，JavaScript 也不能有限表示 1/10、1/2 等这样的分数。在二进制中，1/10(0.1)被表示为 0.00110011001100110011…… 注意 0011 是无限重复的，这是舍入误差造成的，所以对于 0.1 + 0.2 这样的运算，操作数会先被转成二进制，然后再计算：

     0.1 => 0.0001 1001 1001 1001…（无限循环）

     0.2 => 0.0011 0011 0011 0011…（无限循环）


     双精度浮点数的小数部分最多支持 52 位，所以两者相加之后得到这么一串 0.0100110011001100110011001100110011001100...因浮点数小数位的限制而截断的二进制数字，这时候，再把它转换为十进制，就成了 0.30000000000000004。


     对于保证浮点数计算的正确性，有两种常见方式。


     一是先升幂再降幂：

     function add(num1, num2){

     let r1, r2, m;

     r1 = (''+num1).split('.')[1].length;

     r2 = (''+num2).split('.')[1].length;


     m = Math.pow(10,Math.max(r1,r2));

     return (num1 * m + num2 * m) / m;

     }

     console.log(add(0.1,0.2));   //0.3

     console.log(add(0.15,0.2256)); //0.3756


     二是是使用内置的 toPrecision() 和 toFixed() 方法，注意，方法的返回值字符串。

     function add(x, y) {

     return x.toPrecision() + y.toPrecision()

     }

     console.log(add(0.1,0.2));  //"0.10.2"
     * */




    /*9、实现函数 isInteger(x) 来判断 x 是否是整数*/
    /*可以将 x 转换成10进制整数，判断和本身是不是相等即可：*/
    function isInteger(x){
        return parseInt(x, 10) === x;
    }
    console.log('1.2 is an integer?'+isInteger(1.2)); // false
    console.log('35 is an integer?'+isInteger(35)); // true
    /*
     * ES6 对数值进行了扩展，提供了静态方法 isInteger() 来判断参数是否是整数：

     Number.isInteger(25) // true

     Number.isInteger(25.0) // true

     Number.isInteger(25.1) // false

     Number.isInteger("15") // false

     Number.isInteger(true) // false


     JavaScript能够准确表示的整数范围在 -2^53 到 2^53 之间（不含两个端点），超过这个范围，
     无法精确表示这个值。ES6 引入了Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER
     这两个常量，用来表示这个范围的上下限，并提供了 Number.isSafeInteger() 来判断整数是
     否是安全型整数。
     * */



    /*
     10、在下面的代码中，数字 1-4 会以什么顺序输出？为什么会这样输出？*/
    /*
     (function() {
     console.log(1);
     setTimeout(function(){console.log(2)}, 1000);
     setTimeout(function(){console.log(3)}, 0);
     console.log(4);
     })();
     */
    /*输出结果： 1 4 3 2
     * 原理：javascript单线程机制*/




    /*11、写一个少于 80 字符的函数，判断一个字符串是不是回文字符串*/
    function isPalindrome(str){
        //str = str.replace(/\W/,'').toLowerCase();
        /*
         *  \w: 用于匹配所有字母，数字，下划线字符；
         *  \W: 用于匹配所有与\w不匹配的字符；
         * */
        return (str === str.split('').reverse().join(''));
    }

    console.log(isPalindrome('1 $bb$1')); // false
    console.log(isPalindrome('1$bb$1')); // true




    /*12、写一个按照下面方式调用都能正常工作的 sum 方法*/
    /* console.log(sum(2,3));   // Outputs 5
     console.log(sum(2)(3));  // Outputs 5*/
    function sum(){
        var fir = arguments[0];
        if(arguments.length == 2){
            return arguments[0] + arguments[1];
        }else{
            return function(m){
                console.log(m); // 20  3
                return m + fir;
            };
        }
    }
    console.log(sum(0,-1)); // -1
    console.log(sum(10)(20)); // 30
    console.log(sum(2)(3)); // 5




    /*13、根据下面的代码片段回答后面的问题*/
    for (var i = 0; i < 5; i++) {
        var btn = document.createElement('button');
        btn.appendChild(document.createTextNode('Button ' + i));

//btn.addEventListener('click', function(){ console.log(i); });
        //改进：
        btn.addEventListener('click', (function(m){
            return function(){
                console.log(m);
            };
        })(i));

        /*btn.onclick = (function(m){
         return function(){
         console.log(m);
         };
         })(i);*/

        document.body.appendChild(btn);

    }

    /*
     * 1、点击 Button 4，会在控制台输出什么？
     2、给出一种符合预期的实现方式

     1、点击5个按钮中的任意一个，都是输出5
     2、参考 IIFE。
     * */

    var oUl = document.createElement('ul');
    for(var i=0; i<10; i++){
        var oLi = document.createElement('li');
        oLi.appendChild(document.createTextNode('i am li '+ i));
        oLi.onclick = (function(m){
            return function(){
                alert(m);
            };
        })(i);
        oUl.appendChild(oLi);
    }
    document.body.appendChild(oUl);







    /*14、下面的代码会输出什么？为什么？*/
    // split()把字符串分割成字符串数组
    // reverse() 会改变数组本身，**并返回原数组的引用**。!!!!
    var arr1 = "john".split('');  // arr1=["j","o","h","n"]

    var arr2 = arr1.reverse(); // arr1 = arr2 = ["n","h","o","j"]; arr1 and arr2有相同的引用

    var arr3 = "jones".split(''); // arr3=["j","o","n","e","s"];

    arr2.push(arr3); // arr2=["n","h","o","j",["j","o","n","e","s"]]
    // arr1 and arr2有相同的引用 so: arr1=["n","h","o","j",["j","o","n","e","s"]]

    console.log("array 1: length=" + arr1.length + " last=" + arr1.slice(-1));
    // array 1: length=5 last=j,o,n,e,s

    console.log("array 2: length=" + arr2.length + " last=" + arr2.slice(-1));
    // array 2: length=5 last=j,o,n,e,s


    var myArr = [1,2,3,4];
    var myArr2 = [5,6,7,8];
    console.log(myArr.slice(-1)); // [4]
    myArr.push(myArr2);
    console.log(myArr); // [1, 2, 3, 4, Array[4]]






    /*15、下面的代码会输出什么？为什么？*/
    console.log(1 +  "2" + "2"); // 122

    console.log(1 +  +"2" + "2"); // 32

    console.log(1 +  -"1" + "2"); // 02

    console.log(+"1" +  "1" + "2"); // 112

    console.log( "A" - "B" + "2"); // NaN2

    console.log( "A" - "B" + 2); // NaN

    /*
     *     多个数字和数字字符串混合运算时，跟操作数的位置有关

     console.log(2 + 1 + '3'); / /‘33’

     console.log('3' + 2 + 1); //'321'

     数字字符串之前存在数字中的正负号(+/-)时，会被转换成数字

     console.log(typeof '3');   // string

     console.log(typeof +'3');  //number


     同样，可以在数字前添加 ''，将数字转为字符串

     console.log(typeof 3);   // number

     console.log(typeof (''+3));  //string

     对于运算结果不能转换成数字的，将返回 NaN

     console.log('a' * 'sd');   //NaN

     console.log('A' - 'B');  // NaN
     * */




    /*16、如果 list 很大，下面的这段递归代码会造成堆栈溢出。如何在不改变递归模式的前提下修善这段代码？*/
    var list = ['1','2','3','1'];
    var nextListItem = function(){
        var item = list.pop();
        console.log('item'+item);
        if(item){
            nextListItem();
        }
    };
    nextListItem();

    //改进：
    var list = ['1','2','3','1'];
    var nextListItem = function(){
        if(list.length > 0){ // 解决堆栈溢出的bug---指定递归结束的条件！！！
            var item = list.pop();
            console.log('item'+item);
        }
        if(item){
            nextListItem();
        }
    };
    nextListItem();




    /*18、下面的代码会输出什么？为啥？*/
    /*for (var i = 0; i < 5; i++) {
        setTimeout(function() {
            console.log(i);
        }, i * 1000 );
    }*/
    // result: 全是5
    //改进：采用立即执行函数表达式 mmediately-Invoked Function Expression
    /*for (var i = 0; i < 5; i++) {
        (function(n){
            setTimeout(function(){
                console.log(n+'test');
            },n*1000);
        })(i);
    }*/
    //result: 0,1,2,3,4

    //类似的对比：
    for(var i=0; i<5; i++){
        setTimeout(function(){
            console.log(i);
        }, 1000);
    }

    // 改成立即执行函数
    for(var i=0; i<5; i++){
        (function(m){
            setTimeout(function(){
                console.log(m);
            }, 1000);
        })(i);
    }

    //同样的例子
    function test3(){
        var result = [];
        for(var i=0; i<10; i++){
            result[i] = function(num){
                return function(){
                    alert(num);
                }
            }(i);
            //也可以这样写
            /*(function(m){
             result[m] = function(){
             alert(m);
             };
             })(i);*/
        }
        return result;
    }




    /*19、解释下列代码的输出*/
    //逻辑或：返回第一个是 true 的操作数 或者 最后一个是 false的操作数
    console.log("0 || 1 = "+(1 || 0)); // 1

    console.log("1 || 2 = "+(1 || 2)); // 1

    //逻辑与： 逻辑与返回第一个是 false 的操作数 或者 最后一个是 true的操作数
    console.log("0 && 1 = "+(0 && 1)); // 0

    console.log("1 && 2 = "+(1 && 2)); // 2

    /*
     * 如果逻辑与和逻辑或作混合运算，则逻辑与的优先级高：

     console.log(1 && 2 || 0); //2

     console.log(0 || 2 && 1); //1

     console.log(0 && 2 || 1); //1

     在 JavaScript，常见的 false 值：

     0, '0', +0, -0, false, '',null,undefined,null,NaN


     要注意空数组([])和空对象({}):

     console.log([] == false) //true

     console.log({} == false) //false

     console.log(Boolean([])) //true

     console.log(Boolean({})) //true
     所以在 if 中，[] 和 {} 都表现为 true
     * */




    /*20、解释下面代码的输出*/
    console.log(false == '0'); // true ==表示值相同

    console.log(false === '0'); // false  ===表示值和类型都相同





    /*21、解释下面代码的输出*/
    var a={},
            b={key:'b'},
            c={key:'c'};
    a[b]=123;
    a[c]=456;

    console.log(a[b]); // 456






    /*22、解释下面代码的输出*/
    console.log((function f(n){return ((n > 1) ? n * f(n-1) : n)})(10)); // 10!

    function calFactorial(n){
        return ((n>1) ? n * calFactorial(n-1) : n);
    }
    console.log(calFactorial(10));



    (function(x) {
        return (function(y) {
            console.log(x);
        })(2)
    })(1);
    // result: 1  输出1，闭包能够访问外部作用域的变量或参数。




    /*24、解释下面代码的输出，并修复存在的问题*/

    var hero = {

        _name: 'John Doe',

        getSecretIdentity: function (){

            return this._name;

        }

    };

    var stoleSecretIdentity = hero.getSecretIdentity;

    console.log(hero.getSecretIdentity());  // John Doe
    console.log(stoleSecretIdentity()); // undefined   [window.stoleSecretIdentity()]

    //修复： 使用call或者 apply来改变对象的this指向的内容
    console.log(stoleSecretIdentity.call(hero));


    //concat
    var question = [
        {
            "id": 1,
            "name": "aaa"
        },
        {
            "id": 2,
            "name": "bbb"
        }
    ];
    var newQst = {
        "id": 1,
        "name": "aaa"
    };

    console.log(question.concat(newQst));



</script>
</body>
</html>