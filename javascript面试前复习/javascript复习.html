<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>
    // 1.正则表达式
    var string1 = 'ab%12.25$'; // 要得到12.25$
    console.log(string1.replace(/[^{\d,{.},{$}}]/ig,'')); // 12.25$
    // 找到第一个出现数字的位置
    var string2 = 'fdjk@1.23efj';
    console.log(string2.search(/\d/));
    //5).除了大写字母和数字以外的
    var string5 = '#jTyhT$T78s0s';
    console.log(string5.replace(/[^\d,^A-Z]/g,''));

    // 2.闭包
    // 函数嵌套函数；内层函数可以访问外层函数的参数和变量
    // 闭包只能取得包含函数中任何变量的最后一个值
    function test1(){
        var result = [];
        for(var i=0; i<5; i++){
            result[i] = function(){
                alert(i);
            }
        }
        return result;
    }
    //test1()[2]();  // 5  [0,1,2,3,4弹出的结果全部都是5]

    /*变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实
     都是一个新的变量，所以最后输出的是*/
    function test2(){
        var result = [];
        for(let i=0; i<5; i++){
            result[i] = function(){
                alert(i);
            };
        }
        return result;
    }
    //test2()[2](); // 2

    // 我们可以通过创建另一个匿名函数强制让闭包的行为符合预期
    function test3(){
        var result = [];
        for(var i=0; i<5; i++){
            (function(m){
                result[m] = function(){
                    alert(m);
                }
            })(i);
        }
        return result;
    }
    //test3()[2](); // 2

    //闭包的由来
    // 首先，在函数的外部自然无法读取函数内的局部变量
    function f1(){
        var n = 999;
    }
    //console.log(n); // n is not defined

    //出于种种原因，我们有时候需要得到函数内的局部变量。
    // 但是，前面已经说过了，正常情况下，这是办不到的，只
    // 有通过变通方法才能实现。
    //那就是在函数的内部，再定义一个函数。

    //闭包可以用在许多地方。它的最大用处有两个，
    // 一个是前面提到的可以读取函数内部的变量，
    // 另一个就是让这些变量的值始终保持在内存中。（不会被回收机制所回收）

    //匿名函数的this通常指向window
    /*var name = 'window';
     var obj = {
     name: 'my obj',
     getNameFun: function(){
     return function(){
     return this.name;
     }
     }
     };
     console.log(obj.getNameFun()()); // window*/

    var name = 'window';
    var obj = {
        name: 'my obj',
        getNameFun: function(){
            var that = this;
            return function(){
                return that.name;
            }
        }
    };
    console.log(obj.getNameFun()()); // my obj

    //判断一个字符串中出现次数最多的字符以及次数
    var str = 'abcdeabcabcaab';
    var json = {};
    for(var i=0; i< str.length; i++){
        if(!json[str.charAt(i)]){
            json[str.charAt(i)] = 1;
        }else{
            json[str.charAt(i)]++;
        }
    }
    var iMax = 0;
    var ss = '';
    for(var i in json){
        if(json[i] > iMax){
            iMax = json[i];
            ss = i;
        }
    }
    console.log('出现次数最多的是'+ss+',次数是'+iMax); // 出现次数最多的是a,次数是5

    //获取json对象的长度
    var json1 = {"name":"jessie","sex":"female","age":"23"};
    // json对象没有length属性，不能json.length
    console.log(json1.length); // undefined
    function getJsonLength(json){
        var jsonLength = 0;
        for(var i in json1){
            jsonLength++;
        }
        return jsonLength;
    }
    console.log(getJsonLength(json1)); // 3

    //call apply的用法以及意义
    // 二者共同作用是： 改变对象的this指向的内容
    // 写法不同：
    // fun.call(fun1, var1, var2, var3)
    // fun.apply(fun1, [var1,var2, var3])
    // 使用apply的好处是可以将当前函数的arguments对象作为apply的第二个参数传入
    function obj(){
        this.value = '对象';
    }
    var value = 'global对象';
    function fun1(){
        console.log(this.value);
    }
    window.fun1(); //global对象
    fun1.call(window); // global对象
    //fun1.call(document.getElementById('myText')); // input text
    //fun1.call(new obj()); //对象


    // 数组去重
    function unique(arr){
        var result = [],isRepeat= false;
        for(var i=0; i<arr.length; i++){
            for(var j=0; j<result.length; j++){
                if(arr[i] === result[j]){
                    isRepeat = true; // 重复了
                    break;
                }
            }
            if(!isRepeat){
                result.push(arr[i]);
            }
        }
        return result;
    }
    var arr1 = [1,2,3,4,2,12,1];
    console.log(unique(arr1));

    //es6中有提出一种去重的方法
    //ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是【唯一】的，没有重复的值。
    var repeatArr = [1,2,3,4,3,2,1,2,3];
    function uniqueSet(arr){
        return [...new Set(arr)]; // 返回的是set数组结构
    }
    console.log(uniqueSet(repeatArr)); // [1, 2, 3, 4]

    //Array.from方法可以将Set结果转为数组
    var set1 = new Set([1,2,3,2,1]);
    console.log(Array.from(set1)); // [ 1, 2, 3 ]
    //这就提供了数组去重的另一种方法
    function unique2(arr){
        return Array.from(new Set(arr));
    }
    var arr2 = [1,2,3,2,1,0];
    console.log(unique2(arr2)); // [ 1, 2, 3, 0 ]

    //变量提升、函数声明提升
    /*alert(x);
    var x = "111";
    alert(x);
    x="222";
    function x(){return x;}
    alert(x);*/

    /*var x; // 变量提升
    function x(){return x;} // 函数声明提升
    alert(x);
    x = "111";
    alert(x);
    x="222";
    alert(x);*/
    // 结果：
    // 先弹出function x(){return x;}
    // 在弹出111
    // 最后弹出222

    function Foo() {
        getName = function () { alert (1); };
        return this;
    }
    Foo.getName = function () { alert (2);};
    Foo.prototype.getName = function () { alert (3);};
    var getName = function () { alert (4);};
    function getName() { alert (5);}

    // 等价于：
    var getName;
    function getName() { alert (5);}
    function Foo() {
        getName = function () { alert (1); };
        return this;
    }
    Foo.getName = function () { alert (2);};
    Foo.prototype.getName = function () { alert (3);};
    getName = function () { alert (4);};

    /*Foo.getName();  // 2
    getName();  // 4
    Foo().getName();  // 1
    getName(); // 1
    new Foo.getName(); // 2
    new Foo().getName();  // 3
    new new Foo().getName();  // 3*/


    // 深度克隆---js对象引用
    /*var a = [1,2,3];
    var b = a; // a b共用一个引用
    b.push(4);
    alert(b); // [1,2,3,4]
    alert(a); // [1,2,3,4]*/

    /*var a = [1,2,3];
    var b = a;
    b = [1,2,3,4]; // b新开了一个引用
    alert(b); // [1,2,3,4]
    alert(a); // [1,2,3]*/

    /*var obj = {
        a: 10
    };
    var obj2 = obj;
    obj2.a = 20;
    alert(obj.a);// 20*/

    /*var obj = {
     a: 10
     };
     function copy(obj){ // 浅拷贝, 只拷贝的一层
     var newObj = {};
     for(var attr in obj){
     newObj[attr] = obj[attr];
     }
     return newObj;
     }
     var obj2 = copy(obj);
     obj2.a = 20;
     alert(obj.a); // 10*/


    //求nX(n-1)X(n-2)X...X2X1
    // 递归：（1）函数调用函数自身，执行递的动作
    //      （2）最后一次判断一个终止条件，可以执行归的动作
    /*function test(n){
     if(n == 1){
     return 1;
     }
     return n*test(n-1);
     }
     alert(test(5)); // 120*/


    // arguments的应用
    /*function factorial(n){
        if (n <= 0){
            return 1;
        } else{
            return n * arguments.callee(n-1);
        }
    }
    alert(factorial(5)); // 120*/

    function deepClone(obj){
        var newObj = {};
        if(typeof obj != 'object'){
            return obj;
        }
        for(var attr in obj){
            newObj[attr] = deepClone(obj[attr]);
        }
        return newObj;
    }

    //判断一个对象是否具有某个属性
    //对象的写法
    var myObj = {
        "width": 1,
        "height": 2
    };
    if(myObj["width"]){
        console.log('width')
    }
    if(myObj.height){
        console.log('height');
    }

    //判断js对象是否拥有某属性
    // 1.in 运算符
    console.log("width" in myObj); // true
    console.log('toString' in myObj);
    //可看到无论是name，还是原形链上的toString，都能检测到返回true
    // 2.hasOwnProperty
    console.log(myObj.hasOwnProperty('width')); // true
    console.log(myObj.hasOwnProperty('toString')); // false
    //原型链上继承过来的属性无法通过hasOwnProperty检测到，返回false。
    Object.prototype.say = 'hello';// 添加到对象Object上面
    for(var i in myObj){
        console.log(myObj[i]); // 1 2 hello
    }
    var test = [1,2,3,4];
    Array.prototype.say = 'hello';//添加到数组Array上面
    for(var i in test){
        console.log(test[i]); // 1 2 3 4 hello
    }

    //解决办法：
    Object.prototype.say = "hello"; // 添加到对象Object上面
    for(var i in myObj){
        if(myObj.hasOwnProperty(i)){
            console.log(myObj[i]);
        }
    }


    // js dom操作获取节点的一些常用的方法
    // js获取下一个兄弟节点
    function getNextSiblings(eleObj){
        var next = eleObj.nextSiblings;
        if(next.nodeType === 3){ // 文本节点
            return next.nextSiblings;
        }
        return next;
    }

    // js获取上一个兄弟节点
    function getPreviousSiblings(eleObj){
        var pre = eleObj.previousSiblings;
        if(pre.nodeType === 3){
            return pre.previousSiblings;
        }
        return pre;
    }

    //js获取所有子节点
    function getChildNodes(parentNode){
        var childs = [];
        for(var i=0; i<parentNode.childNodes.length; i++){
            if(parentNode.childNodes[i].nodeType == 1){ // 元素节点
                childs.push(parentNode.childNodes[i]);
            }
        }
        return childs;
    }

    //js获取第一个子节点
    function getFirstChildNode(parentNode){
        var first = parentNode.firstChild;
        if(first.nodeType == 3){ // 文本节点
            return first.nextSibling;
        }
        return first;
        /*return parentNode.firstElementChild;*/
    }
    //js获取最后一个子节点
    function getLastChildNode(parentNode){
        var last = parentNode.lastChild;
        if(last.nodeType == 3){
            return last.nextSibling;
        }
        return last;
    }


    //创建一个函数，用以解析查询字符串，然后返回包含所有参数的一个对象
    // window.location.search ==> "?q=javascript" ==>返回URL的查询字符串。这个字符串以问号开头
    function getQueryStringArgs(url){
        url = url === null ? window.location.href : url;
        var qs = url.substring(url.lastIndexOf('?')+1);
        var items = qs.length > 0 ? qs.split('&') : [];
        var item = null;
        var name = null;
        var value = null;
        var args = {};
        for(var i=0; i<items.length; i++){
            item = items[i].split('=');
            name = decodeURIComponent(item[0]);
            value = decodeURIComponent(item[1]);
            if(name.length){
                args[name] = value;
            }
        }
        return args;
    }
    console.log(getQueryStringArgs('http://www.cuit.edu.cn?name=jessie&pass=123'));// { name: "jessie", pass: "123" }

    function getQueryStringArgs2(url){
        url = url === null ? window.location.href : url;
        var qs = url.substring(url.lastIndexOf('?')+1);
        var items = qs.length > 0 ? qs.split('&') : [];
        var obj = {};
        var reg = /([^?&=]+)=([^?&=]*)/g;
        // [^?&=]+表示：除了？、&、=之外的一到多个字符
        // [^?&=]*表示：除了？、&、=之外的0到多个字符（任意多个）
        qs.replace(reg, function(rs, $1, $2){
            var name = decodeURIComponent($1);
            var value = decodeURIComponent($2);
            value = String(value);
            obj[name] = value;
            return rs;
        })
        return obj;
    }
    console.log(getQueryStringArgs2('http://www.cuit.edu.cn?name=jessie&pass=123'));//{ name: "jessie", pass: "123" }


    //描述一下js里面事件的三个阶段










</script>

</body>
</html>