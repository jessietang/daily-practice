<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>javavscript面试常见题型</title>
</head>
<body>
    <div id="div1">
        <p class="p1"></p>
        <p class="p2">
            <span>111</span>
        </p>
        <a href="" class="a1"></a>
        <a href="" class="a2"></a>
    </div>
    <script src="js/jquery-1.11.2.js"></script>
    <script type="text/javascript">

        /*1、使用 typeof bar === "object" 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？*/
        var obj = {};
        var arr = [];
        console.log(typeof obj === 'object'); //true
        console.log(typeof arr === 'object'); //true
        console.log(typeof null === 'object'); //true
        /*从上面的输出结果可知，typeof bar === "object" 并不能准确判断 bar 就是一个 Object。
        可以通过 Object.prototype.toString.call(bar) === "[object Object]" 来避免这种弊端：*/
        console.log(Object.prototype.toString.call(obj)); //[object Object]
        console.log(Object.prototype.toString.call(arr)); //[object Array]
        console.log(Object.prototype.toString.call(null)); //[object Null]

        /*2、下面的代码会在 console 输出神马？为什么？*/
        (function(){
            var a = b = 3;
        })();
        /*console.log("a defined? " + (typeof a !== 'undefined'));
        console.log("b defined? " + (typeof b !== 'undefined'));*/
        //console.log(a); // a is not defined
        console.log(b); // 3
        /*拆解一下自执行函数中的变量赋值：
         b = 3;
         var a = b;
         所以 b 成了全局变量，而 a 是自执行函数的一个局部变量。*/

        /*3、下面的代码会在 console 输出神马？为什么？*/
        var myObject = {
            foo: "bar",
            func: function() {
                var self = this;
                console.log("outer func:  this.foo = " + this.foo);
                console.log("outer func:  self.foo = " + self.foo);
                (function() {
                    console.log("inner func:  this.foo = " + this.foo);
                    console.log("inner func:  self.foo = " + self.foo);
                }());
            }
        };
        myObject.func();
        /*
        * 输出结果：
         outer func:  this.foo = bar
         outer func:  self.foo = bar
         inner func:  this.foo = undefined
         inner func:  self.foo = bar
        * */
        /* //在全局函数中，this 等于window，而当函数被作为某个对象的方法调用时，this 等
         //于那个对象。不过，匿名函数的执行环境具有全局性，因此其this 对象通常指向window*/
        /*用闭包解决：
         (function(test) {
         console.log("inner func:  this.foo = " + test.foo);  //'bar'
         console.log("inner func:  self.foo = " + self.foo);
         }(self));
        * */

        /*4、将 JavaScript 代码包含在一个函数块中有神马意思呢？为什么要这么做？
        * 换句话说，为什么要用立即执行函数表达式（Immediately-Invoked Function Expression）。
         IIFE 有两个比较经典的使用场景，一是类似于在循环中定时输出数据项，
         二是类似于 JQuery/Node 的插件和模块开发。
        * */
        /*for(var i = 0; i < 5; i++) {
            setTimeout(function() {
                console.log(i);
            }, 1000);
        }*/
        /*上面的输出并不是你以为的0，1，2，3，4，而输出的全部是5，这时 IIFE 就能有用了：*/
        /*for(var i = 0; i < 5; i++) {
            (function(m){
                setTimeout(function() {
                    console.log(m);
                }, 1000);
            })(i);
        }*/
        /* 输出 0，1，2，3，4 */
        /*而在 JQuery/Node 的插件和模块开发中，为避免变量污染，也是一个大大的 IIFE：*/
        (function($){
            //代码
        })(jQuery);


       /* 5、在严格模式('use strict')下进行 JavaScript 开发有神马好处？*/

        /*1)消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;

        2)消除代码运行的一些不安全之处，保证代码运行的安全；

        3)提高编译器效率，增加运行速度；

        4)为未来新版本的Javascript做好铺垫。*/


        /*6、下面两个函数的返回值是一样的吗？为什么？*/
        function foo1()
        {
            return {
                bar: "hello"
            };
        }

        function foo2()
        {
            return
            {
                bar: "hello"
            };
        }
        console.log(foo1()); // Object {bar: "hello"}
        console.log(foo2()); // undefined
        /*
        * 在编程语言中，基本都是使用分号（;）将语句分隔开，这可以增加代码的可读性和整洁性。
        * 而在JS中，如若语句各占独立一行，通常可以省略语句间的分号（;），JS 解析器会根据能
        * 否正常编译来决定是否自动填充分号：
         var test = 1 +
         2
         console.log(test);  //3
         在上述情况下，为了正确解析代码，就不会自动填充分号了，但是对于 return 、break、continue 等语句，
         如果后面紧跟换行，解析器一定会自动在后面填充分号(;)，所以上面的第二个函数就变成了这样：
         function foo2()
         {
            return;
             {
             bar: "hello"
             };
         }
         所以第二个函数是返回 undefined。
         * */


        /*7、神马是 NaN，它的类型是神马？怎么测试一个值是否等于 NaN?*/
        /*NaN 是 Not a Number 的缩写，JavaScript 的一种特殊数值，
        其类型是 Number，!!!
        可以通过 isNaN(param) 来判断一个值是否是 NaN：*/
        console.log(isNaN(NaN)); //true

        console.log(isNaN(23)); //false

        console.log(isNaN('ds')); //true

        console.log(isNaN('32131sdasd')); //true

        console.log(NaN === NaN); //false !!!

        console.log(NaN === undefined); //false

        console.log(undefined === undefined); //true !!!

        console.log(typeof NaN); //number !!!

        console.log(Object.prototype.toString.call(NaN)); //[object Number]

        //alert(NaN+1);  // NaN
        /*javascript:alert(NaN+1);结果是无穷大.
         但唯一的是NaN是一个不确定数,所以NaN不能等于NaN.
         这好比是randomise中的random,random +1 还是一个不确定的数值,但random不会等于
         random一样.两者的区别在于random能生成一个确定数,但本身不确定.而NaN生成的就是
         一个不确定数.*/

        /*Object.is() 用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。*/
        /*不同之处只有两个：一是+0不等于-0，二是NaN等于自身。*/
        /*ES5比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。
         它们都有缺点，前者会自动转换数据类型，
         后者的NaN不等于自身，以及+0等于-0。*/
        console.log(NaN === NaN); // false
        console.log(+0 === -0); // true

        console.log(Object.is(NaN,NaN)); // true
        console.log(Object.is(+0,-0)); // false


        /*8、解释一下下面代码的输出*/
        console.log(0.1 + 0.2);   //0.30000000000000004
        console.log(0.1 + 0.2 == 0.3);  //false
        /*
        * JavaScript 中的 number 类型就是浮点型，JavaScript 中的浮点数采用IEEE-754 格式的规定，这是一种二进制表示法，可以精确地表示分数，比如1/2，1/8，1/1024，每个浮点数占64位。但是，二进制浮点数表示法并不能精确的表示类似0.1这样 的简单的数字，会有舍入误差。


         由于采用二进制，JavaScript 也不能有限表示 1/10、1/2 等这样的分数。在二进制中，1/10(0.1)被表示为 0.00110011001100110011…… 注意 0011 是无限重复的，这是舍入误差造成的，所以对于 0.1 + 0.2 这样的运算，操作数会先被转成二进制，然后再计算：

         0.1 => 0.0001 1001 1001 1001…（无限循环）

         0.2 => 0.0011 0011 0011 0011…（无限循环）


         双精度浮点数的小数部分最多支持 52 位，所以两者相加之后得到这么一串 0.0100110011001100110011001100110011001100...因浮点数小数位的限制而截断的二进制数字，这时候，再把它转换为十进制，就成了 0.30000000000000004。


         对于保证浮点数计算的正确性，有两种常见方式。


         一是先升幂再降幂：

         function add(num1, num2){

         let r1, r2, m;

         r1 = (''+num1).split('.')[1].length;

         r2 = (''+num2).split('.')[1].length;


         m = Math.pow(10,Math.max(r1,r2));

         return (num1 * m + num2 * m) / m;

         }

         console.log(add(0.1,0.2));   //0.3

         console.log(add(0.15,0.2256)); //0.3756


         二是是使用内置的 toPrecision() 和 toFixed() 方法，注意，方法的返回值字符串。

         function add(x, y) {

         return x.toPrecision() + y.toPrecision()

         }

         console.log(add(0.1,0.2));  //"0.10.2"
        * */



        /*9、实现函数 isInteger(x) 来判断 x 是否是整数*/
        /*可以将 x 转换成10进制，判断和本身是不是相等即可：*/
        function isInteger(x){
            return parseInt(x, 10) === x;
        }
        console.log('1.2 is an integer?'+isInteger(1.2)); // false
        console.log('35 is an integer?'+isInteger(35)); // true
        /*
        * ES6 对数值进行了扩展，提供了静态方法 isInteger() 来判断参数是否是整数：

         Number.isInteger(25) // true

         Number.isInteger(25.0) // true

         Number.isInteger(25.1) // false

         Number.isInteger("15") // false

         Number.isInteger(true) // false


         JavaScript能够准确表示的整数范围在 -2^53 到 2^53 之间（不含两个端点），超过这个范围，
         无法精确表示这个值。ES6 引入了Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER
         这两个常量，用来表示这个范围的上下限，并提供了 Number.isSafeInteger() 来判断整数是
         否是安全型整数。
        * */



        /*
         10、在下面的代码中，数字 1-4 会以什么顺序输出？为什么会这样输出？*/
        /*
        (function() {
            console.log(1);
            setTimeout(function(){console.log(2)}, 1000);
            setTimeout(function(){console.log(3)}, 0);
            console.log(4);
        })();
        */
        /*输出结果： 1 4 3 2
        * 原理：javascript定时机制和事件循环， 以及javascript是单线程的*/


        /*11、写一个少于 80 字符的函数，判断一个字符串是不是回文字符串*/
        function isPalindrome(str){
            //str = str.replace(/\W/,'').toLowerCase();
            /*
            *  \w: 用于匹配所有字母，数字，下划线字符；
            *  \W: 用于匹配所有与\w不匹配的字符；
            * */
            return (str === str.split('').reverse().join(''));
        }
        console.log(isPalindrome('1 $bb$1')); // false
        console.log(isPalindrome('1$bb$1')); // true



        /*12、写一个按照下面方式调用都能正常工作的 sum 方法*/
       /* console.log(sum(2,3));   // Outputs 5
        console.log(sum(2)(3));  // Outputs 5*/
        function sum(){
            var fir = arguments[0];
            if(arguments.length == 2){
                return arguments[0] + arguments[1];
            }else{
                return function(m){
                    return m + fir;
                };
            }
        }
        console.log(sum(0,-1)); // -1
        console.log(sum(10)(20)); // 30



        /*13、根据下面的代码片段回答后面的问题*/
        for (var i = 0; i < 5; i++) {
            var btn = document.createElement('button');
            btn.appendChild(document.createTextNode('Button ' + i));

            //btn.addEventListener('click', function(){ console.log(i); });
            //改进：
            btn.addEventListener('click', (function(m){
                return function(){
                    console.log(m);
                };
            })(i));

            /*btn.onclick = (function(m){
                return function(){
                    console.log(m);
                };
            })(i);*/

            document.body.appendChild(btn);

        }

        /*
        * 1、点击 Button 4，会在控制台输出什么？
         2、给出一种符合预期的实现方式

         1、点击5个按钮中的任意一个，都是输出5
         2、参考 IIFE。
        * */

        var oUl = document.createElement('ul');
        for(var i=0; i<10; i++){
            var oLi = document.createElement('li');
            oLi.appendChild(document.createTextNode('i am li '+ i));
            oLi.onclick = (function(m){
                return function(){
                    alert(m);
                };
            })(i);
            oUl.appendChild(oLi);
        }
        document.body.appendChild(oUl);




        /*14、下面的代码会输出什么？为什么？*/
        // split()把字符串分割成字符串数组
        // reverse() 会改变数组本身，**并返回原数组的引用**。!!!!
        var arr1 = "john".split('');  // arr1=["j","o","h","n"]

        var arr2 = arr1.reverse(); // arr1 = arr2 = ["n","h","o","j"]; arr1 and arr2有相同的引用

        var arr3 = "jones".split(''); // arr3=["j","o","n","e","s"];

        arr2.push(arr3); // arr2=["n","h","o","j",["j","o","n","e","s"]]
        // arr1 and arr2有相同的引用 so: arr1=["n","h","o","j",["j","o","n","e","s"]]

        console.log("array 1: length=" + arr1.length + " last=" + arr1.slice(-1));
        // array 1: length=5 last=j,o,n,e,s

        console.log("array 2: length=" + arr2.length + " last=" + arr2.slice(-1));
        // array 2: length=5 last=j,o,n,e,s


        var myArr = [1,2,3,4];
        var myArr2 = [5,6,7,8];
        console.log(myArr.slice(-1)); // [4]
        myArr.push(myArr2);
        console.log(myArr); // [1, 2, 3, 4, Array[4]]


        /*15、下面的代码会输出什么？为什么？*/
        console.log(1 +  "2" + "2"); // 122

        console.log(1 +  +"2" + "2"); // 32

        console.log(1 +  -"1" + "2"); // 02

        console.log(+"1" +  "1" + "2"); // 112

        console.log( "A" - "B" + "2"); // NaN2

        console.log( "A" - "B" + 2); // NaN

        /*
        *     多个数字和数字字符串混合运算时，跟操作数的位置有关

         console.log(2 + 1 + '3'); / /‘33’

         console.log('3' + 2 + 1); //'321'

         数字字符串之前存在数字中的正负号(+/-)时，会被转换成数字

         console.log(typeof '3');   // string

         console.log(typeof +'3');  //number


         同样，可以在数字前添加 ''，将数字转为字符串

         console.log(typeof 3);   // number

         console.log(typeof (''+3));  //string

         对于运算结果不能转换成数字的，将返回 NaN

         console.log('a' * 'sd');   //NaN

         console.log('A' - 'B');  // NaN
        * */



        /*16、如果 list 很大，下面的这段递归代码会造成堆栈溢出。如果在不改变递归模式的前提下修善这段代码？*/
        /*var list = ['1','2','3','1'];
        var nextListItem = function(){
            var item = list.pop();
            console.log('item'+item);
            if(item){
                nextListItem();
            }
        };
        nextListItem();*/

        //改进：
        var list = ['1','2','3','1'];
        var nextListItem = function(){
            if(list.length > 0){
                var item = list.pop();
                console.log('item'+item);
            }
            if(item){
                nextListItem();
            }
        };
        nextListItem();



        /*17、什么是闭包？举例说明*/

        //在函数外部自然无法读取函数内的局部变量。
        /*function f1(){
            var n=999;
        }
        alert(n); // error*/

        //出于种种原因，我们有时候需要得到函数内的局部变量。
        // 但是，前面已经说过了，正常情况下，这是办不到的，只
        // 有通过变通方法才能实现。
        //那就是在函数的内部，再定义一个函数。

        //闭包可以用在许多地方。它的最大用处有两个，
        // 一个是前面提到的可以读取函数内部的变量，
        // 另一个就是让这些变量的值始终保持在内存中。（不会被回收机制所回收）
        /*
        function f1(){
            var n=999;
            nAdd=function(){n+=1}; //全局变量
            function f2(){
                alert(n);
            }
            return f2;
        }
        var result=f1();
        result(); // 999
        nAdd();
        result(); // 1000
        */


        //闭包中关于this对象
        //在全局函数中，this 等于window，而当函数被作为某个对象的方法调用时，this 等
        //于那个对象。不过，匿名函数的执行环境具有全局性，因此其this 对象通常指向window
        var name = "The Window";
        var object = {
            name : "My Object",
            getNameFunc : function(){
                return function(){
                    return this.name;
                };
            }
        };
        console.log(object.getNameFunc()()); // The Window 【匿名函数的执行环境具有全局性,this指向window】


        var name = "The Window";
        var object = {
            name : "My Object",
            getNameFunc : function(){
                var that = this;
                return function(){
                    return that.name;
                };
            }
        };
        console.log(object.getNameFunc()()); // My Object



        /*18、下面的代码会输出什么？为啥？*/
        for (var i = 0; i < 5; i++) {
            setTimeout(function() { console.log(i); }, i * 1000 );
        }
        // result: 全是5
        //改进：采用立即执行函数表达式 mmediately-Invoked Function Expression
        for (var i = 0; i < 5; i++) {
            setTimeout((function(i) { console.log(i); })(i), i * 1000 );
        }
        //result: 0,1,2,3,4



        /*19、解释下列代码的输出*/
        //逻辑或：返回第一个是 true 的操作数 或者 最后一个是 false的操作数
        console.log("0 || 1 = "+(1 || 0)); // 1

        console.log("1 || 2 = "+(1 || 2)); // 1

        //逻辑与： 逻辑与返回第一个是 false 的操作数 或者 最后一个是 true的操作数
        console.log("0 && 1 = "+(0 && 1)); // 0

        console.log("1 && 2 = "+(1 && 2)); // 2

        /*
        * 如果逻辑与和逻辑或作混合运算，则逻辑与的优先级高：

         console.log(1 && 2 || 0); //2

         console.log(0 || 2 && 1); //1

         console.log(0 && 2 || 1); //1

         在 JavaScript，常见的 false 值：

         0, '0', +0, -0, false, '',null,undefined,null,NaN


         要注意空数组([])和空对象({}):

         console.log([] == false) //true

         console.log({} == false) //false

         console.log(Boolean([])) //true

         console.log(Boolean({})) //true
         所以在 if 中，[] 和 {} 都表现为 true
         * */



        /*20、解释下面代码的输出*/
        console.log(false == '0'); // true ==表示值相同

        console.log(false === '0'); // false  ===表示值和类型都相同



        /*21、解释下面代码的输出*/
        var a={},
                b={key:'b'},
                c={key:'c'};
        a[b]=123;
        a[c]=456;

        console.log(a[b]); // 456



        /*22、解释下面代码的输出*/
        console.log((function f(n){return ((n > 1) ? n * f(n-1) : n)})(10)); // 10!

        function calFactorial(n){
            return ((n>1) ? n * calFactorial(n-1) : n);
        }
        console.log(calFactorial(10));



        (function(x) {
            return (function(y) {
                console.log(x);
            })(2)
        })(1);
        // result: 1  输出1，闭包能够访问外部作用域的变量或参数。



        /*24、解释下面代码的输出，并修复存在的问题*/

        var hero = {

            _name: 'John Doe',

            getSecretIdentity: function (){

                return this._name;

            }

        };

        var stoleSecretIdentity = hero.getSecretIdentity;

        console.log(stoleSecretIdentity); // undefined   [window.stoleSecretIdentity()]

        //修复： 使用call或者 apply来改变对象的this指向的内容
        console.log(stoleSecretIdentity.call(hero));

        console.log(hero.getSecretIdentity());  // John Doe



        function Traverse(p_element,p_callback) {
            p_callback(p_element);
            console.log(p_element);
            var list = p_element.children;
            for (var i = 0; i < list.length; i++) {
                Traverse(list[i],p_callback);  // recursive call
            }
        }
        var oDiv = document.getElementById('div1');
        Traverse(oDiv,function(){alert('i am call back fun');});
        //console.log(oDiv.children);





        /*25.编写一个函数，去掉数组的重复元素*/
        function unique(arr){
            var result = [], isRepeated;
            for (var i=0; i<arr.length; i++){
                isRepeated = false;
                for(var j=0; j<result.length; j++){
                    if(arr[i] === result[j]){
                        isRepeated = true;
                        break;
                    }
                }
                if(!isRepeated){
                    result.push(arr[i]);
                }
            }
            return result;

        }
        var unUnique = [1,2,3,2,3,1,4];
        console.log(unique(unUnique));




        /*26.如何深度克隆 ---[js对象引用]*/
        function deepClone(obj){
            var newObj = {};
            if(typeof obj != 'object'){
                return obj;
            }
            for(var i in obj){
                newObj[i] = deepClone(obj[i]);
                return newObj;
            }
        }
        var obj1 = {
            a:{
                b:10
            }
        };
        var obj2 = deepClone(obj1);
        obj2.a.b = 20;
        console.log(obj1.a.b); // 10


        /*27.冒泡排序 函数*/
        function sortBubble(arr){
            var temp;
            for(var i=0; i<arr.length; i++){
                for(var j=0; j<arr.length; j++){
                    if(arr[j] > arr[j+1]){
                        temp = arr[j];
                        arr[j] = arr[j+1];
                        arr[j+1] = temp;

                    }
                }
            }
            return arr;
        }
        var bubbleArr = [1,2,3,4,0,-2,20];
        console.log(sortBubble(bubbleArr));


        /*28.快速排序 */
        function quickSort(arr){
            if(arr.length <= 1){
                return arr;
            }
            var leftArr = [],
                    middle= [],
                    rightArr = [];
            var midNum = arr[Math.floor(arr.length / 2)];
            for(var i=0; i<arr.length; i++){
                if(arr[i] < midNum){
                    leftArr.push(arr[i]);
                }else if(arr[i] > midNum){
                    rightArr.push(arr[i]);
                }else{
                    middle.push(arr[i]);
                }
            }
            return [].concat(quickSort(leftArr),middle,quickSort(rightArr));
        }
        var quickArr = [1,2,-1];
        console.log(quickSort(quickArr));


        /*29.平年闰年算法函数*/
        function isLeapYear(nowYear){
            if((nowYear % 4 == 0 && nowYear % 100 != 0) || (nowYear % 100 == 0 && nowYear % 400 == 0)){
                console.log('nowYear is 闰年');
            }else{
                console.log('nowYear is 平年');
            }
        }
        isLeapYear(2016);
    </script>


</body>
</html>